var tipuesearch = {"pages":[{"title":" time_manager ","text":"time_manager Overview This is a morden Fortran time_manager library largely forked from @dongli 's fortran-datetime and inspired from @wavebitscientific 's datetime-fortran There is a very simple test and comprehensive test refer to fortran-datetime . Developer Info Sen Zhao Postdoc in Climate Dynamics, at University of Hawaii at Manoa.","tags":"home","loc":"index.html"},{"title":"test_time_manager.F90 – time_manager","text":"This file depends on sourcefile~~test_time_manager.f90~~EfferentGraph sourcefile~test_time_manager.f90 test_time_manager.F90 sourcefile~time_manager.f90 time_manager.F90 sourcefile~test_time_manager.f90->sourcefile~time_manager.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs test_time_manager Source Code test_time_manager.F90 Source Code program test_time_manager use time_manager implicit none type ( timedelta ) dt_atmos , dt_ocean , dt_cpl , dt_tmp type ( datetime ) Time_curr , Time_strt , Time_last type ( clock ) clock_atmos , clock_ocean real ( 8 ) :: factor , days_prev !! dt_atmos = timedelta ( hours = 4 ) dt_ocean = timedelta ( hours = 12 ) write ( * , * ) dt_atmos % total_days (), \" to \" , dt_ocean % total_days () dt_cpl = dt_ocean - dt_atmos write ( * , * ) dt_cpl % total_hours () dt_cpl = - dt_atmos write ( * , * ) dt_cpl % total_hours () factor = dt_ocean / dt_atmos write ( * , * ) factor Time_strt = datetime ( 1980 , 1 , 1 , 0 , 0 , 0 , calendar = gregorian ) Time_last = datetime ( 1981 , 1 , 1 , 0 , 0 , 0 , calendar = gregorian ) write ( * , * ) Time_strt % isoformat (), \" to \" , Time_last % isoformat () clock_atmos = clock ( Time_strt , Time_last , dt_atmos ) do while (. not . clock_atmos % stopped ) !! write(*, *) clock_atmos%Time%days_in_year() days_prev = int ( clock_atmos % Time % days_in_month ()) call clock_atmos % tick () if ( clock_atmos % alarm_d ) then write ( * , '(A, F12.1, I12, F12.1)' ) clock_atmos % Time % isoformat (), clock_atmos % Time % days_in_year (), clock_atmos % index_d , clock_atmos % axis_d end if !      if( clock_atmos%alarm_m ) then !          write(*, *) clock_atmos%Time%isoformat(), clock_atmos%index_m, clock_atmos%axis_m !      end if end do end program test_time_manager","tags":"","loc":"sourcefile/test_time_manager.f90.html"},{"title":"time_manager.F90 – time_manager","text":"Files dependent on this one sourcefile~~time_manager.f90~~AfferentGraph sourcefile~time_manager.f90 time_manager.F90 sourcefile~test_time_manager.f90 test_time_manager.F90 sourcefile~test_time_manager.f90->sourcefile~time_manager.f90 sourcefile~test2nml_time_manager.f90 test2nml_time_manager.F90 sourcefile~test2nml_time_manager.f90->sourcefile~time_manager.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules time_manager Source Code time_manager.F90 Source Code module time_manager implicit none private public timedelta , datetime , clock public days_of_month public accum_days public days_of_year public is_leap_year public gregorian , noleap !! calendar type integer , parameter :: gregorian = 1 , noleap = 2 !! base date integer , parameter :: default_year = 0001 character ( * ), parameter :: default_units = 'days since 0001-01-01 00:00:00' !!--------------------------- !! definition type timedelta type timedelta real ( 8 ) :: days = 0.0d0 real ( 8 ) :: hours = 0.0d0 real ( 8 ) :: minutes = 0.0d0 real ( 8 ) :: seconds = 0.0d0 real ( 8 ) :: milliseconds = 0.0d0 contains procedure , public :: total_seconds procedure , public :: total_minutes procedure , public :: total_hours procedure , public :: total_days procedure , private :: timedelta_plus_timedelta procedure , private :: timedelta_minus_timedelta procedure , private :: unary_minus_timedelta procedure , private :: timedelta_div_timedelta procedure , private :: timedelta_eq procedure , private :: timedelta_neq procedure , private :: timedelta_gt procedure , private :: timedelta_ge procedure , private :: timedelta_lt procedure , private :: timedelta_le generic :: operator ( + ) => timedelta_plus_timedelta generic :: operator ( - ) => timedelta_minus_timedelta , unary_minus_timedelta generic :: operator ( / ) => timedelta_div_timedelta generic :: operator ( == ) => timedelta_eq generic :: operator ( /= ) => timedelta_neq generic :: operator ( > ) => timedelta_gt generic :: operator ( >= ) => timedelta_ge generic :: operator ( < ) => timedelta_lt generic :: operator ( <= ) => timedelta_le end type timedelta interface timedelta !! initial function set to the same name with type module procedure create_timedelta end interface timedelta !! end definition type timedelta !!--------------------------- !! definition type datetime type datetime integer :: calendar = gregorian integer :: year = 1 integer :: month = 1 integer :: day = 1 integer :: hour = 0 integer :: minute = 0 integer :: second = 0 real ( 8 ) :: millisecond = 0 real ( 8 ) :: timezone = 0.0d0 contains procedure :: init procedure :: isoformat procedure :: timestamp procedure :: format procedure :: add_months procedure :: add_days procedure :: add_hours procedure :: add_minutes procedure :: add_seconds procedure :: add_milliseconds procedure :: days_in_month procedure :: days_in_year procedure :: ceiling_month procedure :: ceiling_day procedure , private :: assign procedure , private :: add_timedelta procedure , private :: sub_datetime procedure , private :: sub_timedelta procedure , private :: eq procedure , private :: neq procedure , private :: gt procedure , private :: ge procedure , private :: lt procedure , private :: le generic :: assignment ( = ) => assign generic :: operator ( + ) => add_timedelta generic :: operator ( - ) => sub_datetime , sub_timedelta generic :: operator ( == ) => eq generic :: operator ( /= ) => neq generic :: operator ( > ) => gt generic :: operator ( >= ) => ge generic :: operator ( < ) => lt generic :: operator ( <= ) => le end type datetime interface datetime !! initial function set to the same name with type module procedure create_datetime_1 module procedure create_datetime_2 end interface datetime !! end definition type datetime !!--------------------------- !! definition type clock type clock type ( datetime ) :: strtTime type ( datetime ) :: lastTime type ( datetime ) :: Time type ( datetime ) :: prevTime type ( timedelta ) :: dt logical :: started = . false . logical :: stopped = . false . logical :: alarm_d !! repeat alarm for daily integer :: index_d = 0 real ( 8 ) :: axis_d = 0.d0 logical :: alarm_m !! repeat alarm for monthly integer :: index_m = 0 real ( 8 ) :: axis_m = 0.d0 contains procedure :: reset procedure :: tick end type clock interface clock !! initial function set to the same name with type module procedure create_clock end interface clock !! end definition type clock contains !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! pure type ( clock ) function create_clock ( d0 , d1 , dt ) result ( res ) class ( datetime ), intent ( in ) :: d0 , d1 class ( timedelta ), intent ( in ) :: dt if ( d1 > d0 ) then res % strtTime = d0 res % Time = d0 res % lastTime = d1 res % dt = dt else res % strtTime = datetime ( 1980 , 1 , 1 , 0 , 0 , 0 ) res % Time = datetime ( 1980 , 1 , 1 , 0 , 0 , 0 ) res % lastTime = datetime ( 1981 , 1 , 1 , 0 , 0 , 0 ) res % dt = timedelta ( hours = 24 ) end if res % index_d = 0 res % index_m = 0 end function create_clock pure elemental subroutine reset ( this ) ! Resets the clock to its start time. class ( clock ), intent ( in out ) :: this this % Time = this % strtTime this % started = . false . this % stopped = . false . end subroutine reset pure elemental subroutine tick ( this ) ! Increments the Time of the clock instance by one dt. class ( clock ), intent ( inout ) :: this if ( this % stopped ) return if ( . not . this % started ) then this % started = . true . this % Time = this % strtTime end if this % prevTime = this % Time this % Time = this % prevTime + this % dt !! alarm for daily if ( this % Time >= this % prevTime % ceiling_day () ) then this % alarm_d = . true . this % index_d = this % index_d + 1 this % axis_d = this % Time % timestamp () - 1 else this % alarm_d = . false . end if !! alarm for monthly if ( this % Time >= this % prevTime % ceiling_month () ) then this % alarm_m = . true . this % index_m = this % index_m + 1 this % axis_m = this % Time % timestamp () - int ( this % prevTime % days_in_month ()) else this % alarm_m = . false . end if if ( this % Time >= this % lastTime ) this % stopped = . true . return end subroutine tick !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! pure type ( timedelta ) function create_timedelta ( days , hours , minutes , seconds , milliseconds ) result ( res ) class ( * ), intent ( in ), optional :: days class ( * ), intent ( in ), optional :: hours class ( * ), intent ( in ), optional :: minutes class ( * ), intent ( in ), optional :: seconds class ( * ), intent ( in ), optional :: milliseconds if ( present ( days )) then select type ( days ) type is ( integer ) res % days = days type is ( real ( 4 )) res % days = days type is ( real ( 8 )) res % days = days end select end if if ( present ( hours )) then select type ( hours ) type is ( integer ) res % hours = hours type is ( real ( 4 )) res % hours = hours type is ( real ( 8 )) res % hours = hours end select end if if ( present ( minutes )) then select type ( minutes ) type is ( integer ) res % minutes = minutes type is ( real ( 4 )) res % minutes = minutes type is ( real ( 8 )) res % minutes = minutes end select end if if ( present ( seconds )) then select type ( seconds ) type is ( integer ) res % seconds = seconds type is ( real ( 4 )) res % seconds = seconds type is ( real ( 8 )) res % seconds = seconds end select end if if ( present ( milliseconds )) then select type ( milliseconds ) type is ( integer ) res % milliseconds = milliseconds type is ( real ( 4 )) res % milliseconds = milliseconds type is ( real ( 8 )) res % milliseconds = milliseconds end select end if end function create_timedelta pure real ( 8 ) function total_seconds ( this ) class ( timedelta ), intent ( in ) :: this total_seconds = this % days * 86400 + this % hours * 3600 + this % minutes * 60 + this % seconds + this % milliseconds * 1.0d-3 end function total_seconds pure real ( 8 ) function total_minutes ( this ) class ( timedelta ), intent ( in ) :: this total_minutes = this % days * 1440 + this % hours * 60 + this % minutes + ( this % seconds + this % milliseconds * 1.0d-3 ) / 6 0.0d0 end function total_minutes pure real ( 8 ) function total_hours ( this ) class ( timedelta ), intent ( in ) :: this total_hours = this % days * 24 + this % hours + ( this % minutes + ( this % seconds + this % milliseconds * 1.0d-3 ) / 6 0.0d0 ) / 6 0.0d0 end function total_hours pure real ( 8 ) function total_days ( this ) class ( timedelta ), intent ( in ) :: this total_days = this % days + ( this % hours + ( this % minutes + ( this % seconds + this % milliseconds * 1.0d-3 ) / 6 0.0d0 ) / 6 0.0d0 ) / 2 4.0d0 end function total_days !! pure elemental type ( timedelta ) function timedelta_plus_timedelta ( t0 , t1 ) result ( t ) ! Adds two `timedelta` instances together and returns a `timedelta` ! instance. Overloads the operator `+`. class ( timedelta ), intent ( in ) :: t0 , t1 t = timedelta ( days = t0 % days + t1 % days , & hours = t0 % hours + t1 % hours , & minutes = t0 % minutes + t1 % minutes , & seconds = t0 % seconds + t1 % seconds , & milliseconds = t0 % milliseconds + t1 % milliseconds ) end function timedelta_plus_timedelta pure elemental type ( timedelta ) function timedelta_minus_timedelta ( t0 , t1 ) result ( t ) ! Subtracts a `timedelta` instance from another. Returns a ! `timedelta` instance. Overloads the operator `-`. class ( timedelta ), intent ( in ) :: t0 , t1 t = t0 + ( - t1 ) end function timedelta_minus_timedelta pure elemental type ( timedelta ) function unary_minus_timedelta ( t0 ) result ( t ) ! Takes a negative of a `timedelta` instance. Overloads the operator `-`. class ( timedelta ), intent ( in ) :: t0 t % days = - t0 % days t % hours = - t0 % hours t % minutes = - t0 % minutes t % seconds = - t0 % seconds t % milliseconds = - t0 % milliseconds end function unary_minus_timedelta pure elemental real ( 8 ) function timedelta_div_timedelta ( t0 , t1 ) result ( factor ) ! Divide two 'timedelta' instances and return a factor, ! Overloads the operator `/`. class ( timedelta ), intent ( in ) :: t0 , t1 factor = t0 % total_seconds () / t1 % total_seconds () end function timedelta_div_timedelta pure elemental logical function timedelta_eq ( this , other ) class ( timedelta ), intent ( in ) :: this class ( timedelta ), intent ( in ) :: other timedelta_eq = this % total_seconds () == other % total_seconds () end function timedelta_eq pure elemental logical function timedelta_neq ( this , other ) class ( timedelta ), intent ( in ) :: this class ( timedelta ), intent ( in ) :: other timedelta_neq = this % total_seconds () /= other % total_seconds () end function timedelta_neq pure elemental logical function timedelta_gt ( this , other ) class ( timedelta ), intent ( in ) :: this class ( timedelta ), intent ( in ) :: other timedelta_gt = this % total_seconds () > other % total_seconds () end function timedelta_gt pure elemental logical function timedelta_ge ( this , other ) class ( timedelta ), intent ( in ) :: this class ( timedelta ), intent ( in ) :: other timedelta_ge = this % total_seconds () >= other % total_seconds () end function timedelta_ge pure elemental logical function timedelta_lt ( this , other ) class ( timedelta ), intent ( in ) :: this class ( timedelta ), intent ( in ) :: other timedelta_lt = this % total_seconds () < other % total_seconds () end function timedelta_lt pure elemental logical function timedelta_le ( this , other ) class ( timedelta ), intent ( in ) :: this class ( timedelta ), intent ( in ) :: other timedelta_le = this % total_seconds () <= other % total_seconds () end function timedelta_le !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine init ( this ) class ( datetime ), intent ( inout ) :: this integer values ( 8 ) call date_and_time ( VALUES = values ) this % year = values ( 1 ) this % month = values ( 2 ) this % day = values ( 3 ) this % hour = values ( 5 ) this % minute = values ( 6 ) this % second = values ( 7 ) this % millisecond = values ( 8 ) end subroutine init pure type ( datetime ) function create_datetime_1 ( & year , month , day , hour , minute , second , millisecond , & julday , days , hours , minutes , seconds , & timestamp , & timezone , calendar ) result ( res ) integer , intent ( in ), optional :: year integer , intent ( in ), optional :: month integer , intent ( in ), optional :: day integer , intent ( in ), optional :: hour integer , intent ( in ), optional :: minute integer , intent ( in ), optional :: second integer , intent ( in ), optional :: millisecond integer , intent ( in ), optional :: julday integer , intent ( in ), optional :: days integer , intent ( in ), optional :: hours integer , intent ( in ), optional :: minutes integer , intent ( in ), optional :: seconds class ( * ), intent ( in ), optional :: timestamp class ( * ), intent ( in ), optional :: timezone integer , intent ( in ), optional :: calendar real ( 8 ) residue_seconds integer mon if ( present ( calendar )) res % calendar = calendar if ( present ( timestamp )) then ! Assume the start date time is UTC 0001-01-01 00:00:00 defined default_year, default_units res % year = default_year res % month = 1 res % day = 1 res % hour = 0 res % minute = 0 res % second = 0 res % millisecond = 0 select type ( timestamp ) type is ( integer ) residue_seconds = timestamp type is ( real ( 4 )) residue_seconds = timestamp type is ( real ( 8 )) residue_seconds = timestamp end select call res % add_days ( int ( residue_seconds / 8640 0.0 )) residue_seconds = mod ( residue_seconds , 8640 0.0 ) call res % add_hours ( int ( residue_seconds / 360 0.0 )) residue_seconds = mod ( residue_seconds , 360 0.0 ) call res % add_minutes ( int ( residue_seconds / 6 0.0 )) residue_seconds = mod ( residue_seconds , 6 0.0 ) call res % add_seconds ( int ( residue_seconds )) call res % add_milliseconds (( residue_seconds - int ( residue_seconds )) * 1000 ) else if ( present ( year )) res % year = year if ( present ( julday )) then res % day = 0 do mon = 1 , 12 res % day = res % day + days_of_month ( year , mon , res % calendar ) if ( res % day > julday ) exit end do res % month = min ( mon , 12 ) res % day = julday - accum_days ( year , res % month , 0 , res % calendar ) else if ( present ( month )) res % month = month if ( present ( day )) res % day = day end if if ( present ( hour )) res % hour = hour if ( present ( minute )) res % minute = minute if ( present ( second )) res % second = second if ( present ( millisecond )) res % millisecond = millisecond if ( present ( days )) call res % add_days ( days ) if ( present ( hours )) call res % add_hours ( hours ) if ( present ( minutes )) call res % add_minutes ( minutes ) if ( present ( seconds )) call res % add_seconds ( seconds ) if ( res % second == 60 ) then call res % add_minutes ( 1 ) res % second = 0 end if if ( res % minute == 60 ) then call res % add_hours ( 1 ) res % minute = 0 end if if ( res % hour == 24 ) then call res % add_days ( 1 ) res % hour = 0 end if end if if ( present ( timezone )) then select type ( timezone ) type is ( integer ) res % timezone = timezone type is ( real ( 4 )) res % timezone = timezone type is ( real ( 8 )) res % timezone = timezone end select end if end function create_datetime_1 type ( datetime ) function create_datetime_2 ( datetime_str , format_str , timezone , calendar ) result ( res ) character ( * ), intent ( in ) :: datetime_str character ( * ), intent ( in ), optional :: format_str class ( * ), intent ( in ), optional :: timezone integer , intent ( in ), optional :: calendar integer i , j , num_spec character ( 1 ), allocatable :: specs (:) ! Date time element specifiers (e.g. 'Y', 'm', 'd') if ( present ( format_str )) then num_spec = 0 i = 1 do while ( i <= len_trim ( format_str )) if ( format_str ( i : i ) == '%' ) then ! % character consumes 1 character specifier. num_spec = num_spec + 1 i = i + 2 else i = i + 1 end if end do allocate ( specs ( num_spec )) i = 1 j = 1 do while ( i <= len_trim ( format_str )) if ( format_str ( i : i ) == '%' ) then i = i + 1 select case ( format_str ( i : i )) case ( 'Y' ) read ( datetime_str ( j : j + 3 ), '(I4)' ) res % year j = j + 4 case ( 'm' ) read ( datetime_str ( j : j + 1 ), '(I2)' ) res % month j = j + 2 case ( 'd' ) read ( datetime_str ( j : j + 1 ), '(I2)' ) res % day j = j + 2 case ( 'H' ) read ( datetime_str ( j : j + 1 ), '(I2)' ) res % hour j = j + 2 case ( 'M' ) read ( datetime_str ( j : j + 1 ), '(I2)' ) res % minute j = j + 2 case ( 'S' ) read ( datetime_str ( j : j + 1 ), '(I2)' ) res % second j = j + 2 case default j = j + 1 end select else j = j + 1 end if i = i + 1 end do else ! TODO: I assume UTC time for the time being. read ( datetime_str ( 1 : 4 ), '(I4)' ) res % year read ( datetime_str ( 6 : 7 ), '(I2)' ) res % month read ( datetime_str ( 9 : 10 ), '(I2)' ) res % day read ( datetime_str ( 12 : 13 ), '(I2)' ) res % hour read ( datetime_str ( 15 : 16 ), '(I2)' ) res % minute read ( datetime_str ( 18 : 19 ), '(I2)' ) res % second end if if ( present ( timezone )) then select type ( timezone ) type is ( integer ) res % timezone = timezone type is ( real ( 4 )) res % timezone = timezone type is ( real ( 8 )) res % timezone = timezone class default write ( * , * ) '[Error]: datetime: Invalid timezone argument type! Only integer and real are supported.' stop 1 end select end if if ( present ( calendar )) res % calendar = calendar end function create_datetime_2 function isoformat ( this ) result ( res ) class ( datetime ), intent ( in ) :: this character (:), allocatable :: res character ( 30 ) tmp if ( this % timezone == 0 ) then write ( tmp , \"(I4.4, '-', I2.2, '-', I2.2, 'T', I2.2, ':', I2.2, ':', I2.2, 'Z')\" ) & this % year , this % month , this % day , this % hour , this % minute , this % second else write ( tmp , \"(I4.4, '-', I2.2, '-', I2.2, 'T', I2.2, ':', I2.2, ':', I2.2, SP, I3.2, ':00')\" ) & this % year , this % month , this % day , this % hour , this % minute , this % second , int ( this % timezone ) end if res = trim ( tmp ) end function isoformat function timestamp ( this , timezone ) class ( datetime ), intent ( in ) :: this class ( * ), intent ( in ), optional :: timezone real ( 8 ) timestamp type ( timedelta ) dt dt = this - datetime ( default_year ) timestamp = dt % total_days () if ( present ( timezone )) then select type ( timezone ) type is ( integer ) timestamp = timestamp - ( this % timezone - timezone ) / 2 4.d0 type is ( real ( 4 )) timestamp = timestamp - ( this % timezone - timezone ) / 2 4.d0 type is ( real ( 8 )) timestamp = timestamp - ( this % timezone - timezone ) / 2 4.d0 end select end if end function timestamp function format ( this , format_str ) result ( res ) class ( datetime ), intent ( in ) :: this character ( * ), intent ( in ) :: format_str character (:), allocatable :: res character ( 100 ) tmp integer i , j tmp = '' i = 1 j = 1 do while ( i <= len_trim ( format_str )) if ( format_str ( i : i ) == '%' ) then i = i + 1 select case ( format_str ( i : i )) case ( 'Y' ) write ( tmp ( j : j + 3 ), '(I4.4)' ) this % year j = j + 4 case ( 'y' ) write ( tmp ( j : j + 1 ), '(I2.2)' ) mod ( this % year , 100 ) j = j + 2 case ( 'j' ) write ( tmp ( j : j + 2 ), '(I3.3)' ) int ( this % days_in_year ()) j = j + 3 case ( 'm' ) write ( tmp ( j : j + 1 ), '(I2.2)' ) this % month j = j + 2 case ( 'd' ) write ( tmp ( j : j + 1 ), '(I2.2)' ) this % day j = j + 2 case ( 'H' ) write ( tmp ( j : j + 1 ), '(I2.2)' ) this % hour j = j + 2 case ( 'M' ) write ( tmp ( j : j + 1 ), '(I2.2)' ) this % minute j = j + 2 case ( 'S' ) write ( tmp ( j : j + 1 ), '(I2.2)' ) this % second j = j + 2 case ( 's' ) write ( tmp ( j : j + 4 ), '(I5.5)' ) this % hour * 3600 + this % minute * 60 + this % second end select else write ( tmp ( j : j ), '(A1)' ) format_str ( i : i ) j = j + 1 end if i = i + 1 end do res = trim ( tmp ) end function format pure subroutine add_months ( this , months ) class ( datetime ), intent ( inout ) :: this integer , intent ( in ) :: months this % month = this % month + months if ( this % month > 12 ) then this % year = this % year + this % month / 12 this % month = mod ( this % month , 12 ) else if ( this % month < 1 ) then this % year = this % year + this % month / 12 - 1 this % month = 12 + mod ( this % month , 12 ) end if end subroutine add_months pure subroutine add_days ( this , days ) class ( datetime ), intent ( inout ) :: this class ( * ), intent ( in ) :: days real ( 8 ) residue_days integer month_days select type ( days ) type is ( integer ) residue_days = 0 this % day = this % day + days type is ( real ( 4 )) residue_days = days - int ( days ) this % day = this % day + days type is ( real ( 8 )) residue_days = days - int ( days ) this % day = this % day + days end select if ( residue_days /= 0 ) then call this % add_hours ( residue_days * 24 ) end if do if ( this % day < 1 ) then call this % add_months ( - 1 ) month_days = days_of_month ( this % year , this % month , this % calendar ) this % day = this % day + month_days else month_days = days_of_month ( this % year , this % month , this % calendar ) if ( this % day > month_days ) then call this % add_months ( 1 ) this % day = this % day - month_days else exit end if end if end do end subroutine add_days pure subroutine add_hours ( this , hours ) class ( datetime ), intent ( inout ) :: this class ( * ), intent ( in ) :: hours real ( 8 ) residue_hours select type ( hours ) type is ( integer ) residue_hours = 0 this % hour = this % hour + hours type is ( real ( 4 )) residue_hours = hours - int ( hours ) this % hour = this % hour + hours type is ( real ( 8 )) residue_hours = hours - int ( hours ) this % hour = this % hour + hours end select if ( residue_hours /= 0 ) then call this % add_minutes ( residue_hours * 60 ) end if if ( this % hour >= 24 ) then call this % add_days ( this % hour / 24 ) this % hour = mod ( this % hour , 24 ) else if ( this % hour < 0 ) then if ( mod ( this % hour , 24 ) == 0 ) then call this % add_days ( this % hour / 24 ) this % hour = 0 else call this % add_days ( this % hour / 24 - 1 ) this % hour = mod ( this % hour , 24 ) + 24 end if end if end subroutine add_hours pure subroutine add_minutes ( this , minutes ) class ( datetime ), intent ( inout ) :: this class ( * ), intent ( in ) :: minutes real ( 8 ) residue_minutes select type ( minutes ) type is ( integer ) residue_minutes = 0 this % minute = this % minute + minutes type is ( real ( 4 )) residue_minutes = minutes - int ( minutes ) this % minute = this % minute + minutes type is ( real ( 8 )) residue_minutes = minutes - int ( minutes ) this % minute = this % minute + minutes end select if ( residue_minutes /= 0 ) then call this % add_seconds ( residue_minutes * 60 ) end if if ( this % minute >= 60 ) then call this % add_hours ( this % minute / 60 ) this % minute = mod ( this % minute , 60 ) else if ( this % minute < 0 ) then if ( mod ( this % minute , 60 ) == 0 ) then call this % add_hours ( this % minute / 60 ) this % minute = 0 else call this % add_hours ( this % minute / 60 - 1 ) this % minute = mod ( this % minute , 60 ) + 60 end if end if end subroutine add_minutes pure subroutine add_seconds ( this , seconds ) class ( datetime ), intent ( inout ) :: this class ( * ), intent ( in ) :: seconds real ( 8 ) residue_seconds select type ( seconds ) type is ( integer ) residue_seconds = 0 this % second = this % second + seconds type is ( real ( 4 )) residue_seconds = seconds - int ( seconds ) this % second = this % second + seconds type is ( real ( 8 )) residue_seconds = seconds - int ( seconds ) this % second = this % second + seconds end select if ( residue_seconds /= 0 ) then call this % add_milliseconds ( residue_seconds * 1000 ) end if if ( this % second >= 60 ) then call this % add_minutes ( this % second / 60 ) this % second = mod ( this % second , 60 ) else if ( this % second < 0 ) then if ( mod ( this % second , 60 ) == 0 ) then call this % add_minutes ( this % second / 60 ) this % second = 0 else call this % add_minutes ( this % second / 60 - 1 ) this % second = mod ( this % second , 60 ) + 60 end if end if end subroutine add_seconds pure subroutine add_milliseconds ( this , milliseconds ) class ( datetime ), intent ( inout ) :: this class ( * ), intent ( in ) :: milliseconds select type ( milliseconds ) type is ( integer ) this % millisecond = this % millisecond + milliseconds type is ( real ( 4 )) this % millisecond = this % millisecond + milliseconds type is ( real ( 8 )) this % millisecond = this % millisecond + milliseconds end select if ( this % millisecond >= 1000 ) then call this % add_seconds ( int ( this % millisecond / 1000 )) this % millisecond = mod ( this % millisecond , 100 0.0 ) else if ( this % millisecond < 0 ) then if ( mod ( this % millisecond , 100 0.0 ) == 0 ) then call this % add_seconds ( int ( this % millisecond / 1000 )) this % millisecond = 0 else call this % add_seconds ( int ( this % millisecond / 1000 ) - 1 ) this % millisecond = mod ( this % millisecond , 100 0.0d0 ) + 1000 end if end if end subroutine add_milliseconds pure type ( datetime ) function ceiling_day ( this ) result ( res ) class ( datetime ), intent ( in ) :: this res = datetime ( this % year , this % month , this % day , 0 , 0 , 0 , calendar = this % calendar ) call res % add_days ( 1 ) return end function ceiling_day pure type ( datetime ) function ceiling_month ( this ) result ( res ) class ( datetime ), intent ( in ) :: this res = datetime ( this % year , this % month , 1 , 0 , 0 , 0 , calendar = this % calendar ) call res % add_months ( 1 ) return end function ceiling_month pure real ( 8 ) function days_in_month ( this ) result ( res ) class ( datetime ), intent ( in ) :: this res = this % day + this % hour / 2 4.0d0 + this % minute / 2 4.0d0 / 60 + this % second / 2 4.0d0 / 3600 + this % millisecond / 2 4.0d0 / 3600 / 1000 end function days_in_month pure real ( 8 ) function days_in_year ( this ) result ( res ) class ( datetime ), intent ( in ) :: this integer month res = 0 do month = 1 , this % month - 1 res = res + days_of_month ( this % year , month , this % calendar ) end do res = res + this % days_in_month () end function days_in_year pure elemental subroutine assign ( this , other ) class ( datetime ), intent ( inout ) :: this class ( datetime ), intent ( in ) :: other this % calendar = other % calendar this % year = other % year this % month = other % month this % day = other % day this % hour = other % hour this % minute = other % minute this % second = other % second this % millisecond = other % millisecond this % timezone = other % timezone end subroutine assign elemental type ( datetime ) function add_timedelta ( this , td ) result ( res ) class ( datetime ), intent ( in ) :: this type ( timedelta ), intent ( in ) :: td res = this call res % add_milliseconds ( td % milliseconds ) call res % add_seconds ( td % seconds ) call res % add_minutes ( td % minutes ) call res % add_hours ( td % hours ) call res % add_days ( td % days ) end function add_timedelta pure elemental type ( datetime ) function sub_timedelta ( this , td ) result ( res ) class ( datetime ), intent ( in ) :: this type ( timedelta ), intent ( in ) :: td res = this call res % add_milliseconds ( - td % milliseconds ) call res % add_seconds ( - td % seconds ) call res % add_minutes ( - td % minutes ) call res % add_hours ( - td % hours ) call res % add_days ( - td % days ) end function sub_timedelta type ( timedelta ) recursive function sub_datetime ( this , other ) result ( res ) class ( datetime ), intent ( in ) :: this class ( datetime ), intent ( in ) :: other integer year , month , days , hours , minutes , seconds real ( 8 ) milliseconds days = 0 hours = 0 minutes = 0 seconds = 0 milliseconds = 0 if ( this >= other ) then if ( this % year == other % year ) then if ( this % month == other % month ) then if ( this % day == other % day ) then if ( this % hour == other % hour ) then if ( this % minute == other % minute ) then if ( this % second == other % second ) then milliseconds = milliseconds + this % millisecond - other % millisecond else seconds = seconds + this % second - other % second - 1 milliseconds = milliseconds + 1000 - other % millisecond milliseconds = milliseconds + this % millisecond end if else minutes = minutes + this % minute - other % minute - 1 seconds = seconds + 60 - other % second - 1 seconds = seconds + this % second milliseconds = milliseconds + 1000 - other % millisecond milliseconds = milliseconds + this % millisecond end if else hours = hours + this % hour - other % hour - 1 minutes = minutes + 60 - other % minute - 1 minutes = minutes + this % minute seconds = seconds + 60 - other % second - 1 seconds = seconds + this % second milliseconds = milliseconds + 1000 - other % millisecond milliseconds = milliseconds + this % millisecond end if else days = days + this % day - other % day - 1 hours = hours + 24 - other % hour - 1 hours = hours + this % hour minutes = minutes + 60 - other % minute - 1 minutes = minutes + this % minute seconds = seconds + 60 - other % second - 1 seconds = seconds + this % second milliseconds = milliseconds + 1000 - other % millisecond milliseconds = milliseconds + this % millisecond end if else do month = other % month + 1 , this % month - 1 days = days + days_of_month ( this % year , month , this % calendar ) end do days = days + days_of_month ( other % year , other % month , other % calendar ) - other % day - 1 days = days + this % day hours = hours + 24 - other % hour - 1 hours = hours + this % hour minutes = minutes + 60 - other % minute - 1 minutes = minutes + this % minute seconds = seconds + 60 - other % second - 1 seconds = seconds + this % second milliseconds = milliseconds + 1000 - other % millisecond milliseconds = milliseconds + this % millisecond end if else do year = other % year + 1 , this % year - 1 if ( this % calendar == gregorian ) then days = days + 365 + merge ( 1 , 0 , is_leap_year ( year )) else days = days + 365 end if end do do month = other % month + 1 , 12 days = days + days_of_month ( other % year , month , other % calendar ) end do do month = 1 , this % month - 1 days = days + days_of_month ( this % year , month , this % calendar ) end do days = days + days_of_month ( other % year , other % month , other % calendar ) - other % day - 1 days = days + this % day hours = hours + 24 - other % hour - 1 hours = hours + this % hour minutes = minutes + 60 - other % minute - 1 minutes = minutes + this % minute seconds = seconds + 60 - other % second - 1 seconds = seconds + this % second milliseconds = milliseconds + 1000 - other % millisecond milliseconds = milliseconds + this % millisecond end if ! Carry over. if ( milliseconds >= 1000 ) then milliseconds = milliseconds - 1000 seconds = seconds + 1 end if if ( seconds >= 60 ) then seconds = seconds - 60 minutes = minutes + 1 end if if ( minutes >= 60 ) then minutes = minutes - 60 hours = hours + 1 end if if ( hours >= 24 ) then hours = hours - 24 days = days + 1 end if res = create_timedelta ( days = days , hours = hours , minutes = minutes , seconds = seconds , milliseconds = milliseconds ) else res = - sub_datetime ( other , this ) end if end function sub_datetime pure elemental logical function eq ( this , other ) class ( datetime ), intent ( in ) :: this class ( datetime ), intent ( in ) :: other eq = this % year == other % year . and . & this % month == other % month . and . & this % day == other % day . and . & this % hour == other % hour . and . & this % minute == other % minute . and . & this % second == other % second . and . & this % millisecond == other % millisecond end function eq pure elemental logical function neq ( this , other ) class ( datetime ), intent ( in ) :: this class ( datetime ), intent ( in ) :: other neq = . not . this == other end function neq pure elemental logical function gt ( this , other ) class ( datetime ), intent ( in ) :: this class ( datetime ), intent ( in ) :: other if ( this % year < other % year ) then gt = . false . return else if ( this % year > other % year ) then gt = . true . return end if if ( this % month < other % month ) then gt = . false . return else if ( this % month > other % month ) then gt = . true . return end if if ( this % day < other % day ) then gt = . false . return else if ( this % day > other % day ) then gt = . true . return end if if ( this % hour < other % hour ) then gt = . false . return else if ( this % hour > other % hour ) then gt = . true . return end if if ( this % minute < other % minute ) then gt = . false . return else if ( this % minute > other % minute ) then gt = . true . return end if if ( this % second < other % second ) then gt = . false . return else if ( this % second > other % second ) then gt = . true . return end if if ( this % millisecond < other % millisecond ) then gt = . false . return else if ( this % millisecond < other % millisecond ) then gt = . true . return end if gt = this /= other end function gt pure elemental logical function ge ( this , other ) class ( datetime ), intent ( in ) :: this class ( datetime ), intent ( in ) :: other ge = this > other . or . this == other end function ge pure elemental logical function lt ( this , other ) class ( datetime ), intent ( in ) :: this class ( datetime ), intent ( in ) :: other lt = other > this end function lt pure elemental logical function le ( this , other ) class ( datetime ), intent ( in ) :: this class ( datetime ), intent ( in ) :: other le = other > this . or . this == other end function le !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! pure integer function days_of_month ( year , month , calendar ) result ( res ) integer , intent ( in ) :: year integer , intent ( in ) :: month integer , intent ( in ) :: calendar integer , parameter :: days ( 12 ) = [ 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] if ( month == 2 . and . is_leap_year ( year ) . and . calendar == gregorian ) then res = 29 else res = days ( month ) end if end function days_of_month pure integer function accum_days ( year , month , day , calendar ) result ( res ) integer , intent ( in ) :: year integer , intent ( in ) :: month integer , intent ( in ) :: day integer , intent ( in ) :: calendar integer mon res = day do mon = 1 , month - 1 res = res + days_of_month ( year , mon , calendar ) end do end function accum_days pure integer function days_of_year ( year , calendar ) result ( res ) integer , intent ( in ) :: year integer , intent ( in ) :: calendar select case ( calendar ) case ( gregorian ) if ( is_leap_year ( year )) then res = 366 else res = 365 end if case ( noleap ) res = 365 end select end function days_of_year pure logical function is_leap_year ( year ) result ( res ) integer , intent ( in ) :: year res = ( mod ( year , 4 ) == 0 . and . . not . mod ( year , 100 ) == 0 ) . or . ( mod ( year , 400 ) == 0 ) end function is_leap_year end module time_manager","tags":"","loc":"sourcefile/time_manager.f90.html"},{"title":"test2nml_time_manager.F90 – time_manager","text":"This file depends on sourcefile~~test2nml_time_manager.f90~~EfferentGraph sourcefile~test2nml_time_manager.f90 test2nml_time_manager.F90 sourcefile~time_manager.f90 time_manager.F90 sourcefile~test2nml_time_manager.f90->sourcefile~time_manager.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs test_time_manager Source Code test2nml_time_manager.F90 Source Code program test_time_manager use time_manager implicit none type ( timedelta ) dt_atmos type ( datetime ) Time_strt , Time_last namelist / time_nml / Time_strt , Time_last , dt_atmos integer :: jm logical :: namelist_file_exists ! Read namelist file inquire ( file = \"input.nml\" , exist = namelist_file_exists ) if ( namelist_file_exists ) then open ( 10 , file = \"input.nml\" ) read ( 10 , nml = time_nml ) close ( 10 ) end if write ( * , '(2A)' ) \" Model runs from \" , Time_strt % isoformat () write ( * , '(2A)' ) \" Model ends at   \" , Time_last % isoformat () write ( * , '(A, F5.3, A)' ) \" dt_atmos = \" , dt_atmos % total_hours (), \" hours\" end program test_time_manager","tags":"","loc":"sourcefile/test2nml_time_manager.f90.html"},{"title":"run.sh – time_manager","text":"/bin/csh Contents Source Code run.sh Source Code #!/bin/csh rm -rf a.out ifort -O2 -Ofast time_manager.F90 test_time_manager.F90 -o a.out rm -rf *.o *.mod ./a.out","tags":"","loc":"sourcefile/run.sh.html"},{"title":"timedelta – time_manager ","text":"type, public :: timedelta Inherited by type~~timedelta~~InheritedByGraph type~timedelta timedelta type~clock clock type~clock->type~timedelta dt Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables days hours minutes seconds milliseconds Constructor timedelta Type-Bound Procedures total_seconds total_minutes total_hours total_days timedelta_plus_timedelta timedelta_minus_timedelta unary_minus_timedelta timedelta_div_timedelta timedelta_eq timedelta_neq timedelta_gt timedelta_ge timedelta_lt timedelta_le operator(+) operator(-) operator(/) operator(==) operator(/=) operator(>) operator(>=) operator( operator(<=) Source Code timedelta Components Type Visibility Attributes Name Initial real(kind=8), public :: days = 0.0d0 real(kind=8), public :: hours = 0.0d0 real(kind=8), public :: minutes = 0.0d0 real(kind=8), public :: seconds = 0.0d0 real(kind=8), public :: milliseconds = 0.0d0 Constructor public interface timedelta initial function set to the same name with type private pure function create_timedelta (days, hours, minutes, seconds, milliseconds) result(res) Arguments Type Intent Optional Attributes Name class(*), intent(in), optional :: days class(*), intent(in), optional :: hours class(*), intent(in), optional :: minutes class(*), intent(in), optional :: seconds class(*), intent(in), optional :: milliseconds Return Value type( timedelta ) Type-Bound Procedures procedure, public :: total_seconds private pure function total_seconds (this) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: this Return Value real(kind=8) procedure, public :: total_minutes private pure function total_minutes (this) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: this Return Value real(kind=8) procedure, public :: total_hours private pure function total_hours (this) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: this Return Value real(kind=8) procedure, public :: total_days private pure function total_days (this) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: this Return Value real(kind=8) procedure, private :: timedelta_plus_timedelta private pure elemental function timedelta_plus_timedelta (t0, t1) result(t) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: t0 class( timedelta ), intent(in) :: t1 Return Value type( timedelta ) procedure, private :: timedelta_minus_timedelta private pure elemental function timedelta_minus_timedelta (t0, t1) result(t) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: t0 class( timedelta ), intent(in) :: t1 Return Value type( timedelta ) procedure, private :: unary_minus_timedelta private pure elemental function unary_minus_timedelta (t0) result(t) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: t0 Return Value type( timedelta ) procedure, private :: timedelta_div_timedelta private pure elemental function timedelta_div_timedelta (t0, t1) result(factor) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: t0 class( timedelta ), intent(in) :: t1 Return Value real(kind=8) procedure, private :: timedelta_eq private pure elemental function timedelta_eq (this, other) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: this class( timedelta ), intent(in) :: other Return Value logical procedure, private :: timedelta_neq private pure elemental function timedelta_neq (this, other) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: this class( timedelta ), intent(in) :: other Return Value logical procedure, private :: timedelta_gt private pure elemental function timedelta_gt (this, other) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: this class( timedelta ), intent(in) :: other Return Value logical procedure, private :: timedelta_ge private pure elemental function timedelta_ge (this, other) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: this class( timedelta ), intent(in) :: other Return Value logical procedure, private :: timedelta_lt private pure elemental function timedelta_lt (this, other) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: this class( timedelta ), intent(in) :: other Return Value logical procedure, private :: timedelta_le private pure elemental function timedelta_le (this, other) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: this class( timedelta ), intent(in) :: other Return Value logical generic, public :: operator(+) => timedelta_plus_timedelta private pure elemental function timedelta_plus_timedelta (t0, t1) result(t) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: t0 class( timedelta ), intent(in) :: t1 Return Value type( timedelta ) generic, public :: operator(-) => timedelta_minus_timedelta , unary_minus_timedelta private pure elemental function timedelta_minus_timedelta (t0, t1) result(t) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: t0 class( timedelta ), intent(in) :: t1 Return Value type( timedelta ) private pure elemental function unary_minus_timedelta (t0) result(t) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: t0 Return Value type( timedelta ) generic, public :: operator(/) => timedelta_div_timedelta private pure elemental function timedelta_div_timedelta (t0, t1) result(factor) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: t0 class( timedelta ), intent(in) :: t1 Return Value real(kind=8) generic, public :: operator(==) => timedelta_eq private pure elemental function timedelta_eq (this, other) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: this class( timedelta ), intent(in) :: other Return Value logical generic, public :: operator(/=) => timedelta_neq private pure elemental function timedelta_neq (this, other) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: this class( timedelta ), intent(in) :: other Return Value logical generic, public :: operator(>) => timedelta_gt private pure elemental function timedelta_gt (this, other) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: this class( timedelta ), intent(in) :: other Return Value logical generic, public :: operator(>=) => timedelta_ge private pure elemental function timedelta_ge (this, other) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: this class( timedelta ), intent(in) :: other Return Value logical generic, public :: operator(  => timedelta_lt private pure elemental function timedelta_lt (this, other) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: this class( timedelta ), intent(in) :: other Return Value logical generic, public :: operator(<=) => timedelta_le private pure elemental function timedelta_le (this, other) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: this class( timedelta ), intent(in) :: other Return Value logical Source Code type timedelta real ( 8 ) :: days = 0.0d0 real ( 8 ) :: hours = 0.0d0 real ( 8 ) :: minutes = 0.0d0 real ( 8 ) :: seconds = 0.0d0 real ( 8 ) :: milliseconds = 0.0d0 contains procedure , public :: total_seconds procedure , public :: total_minutes procedure , public :: total_hours procedure , public :: total_days procedure , private :: timedelta_plus_timedelta procedure , private :: timedelta_minus_timedelta procedure , private :: unary_minus_timedelta procedure , private :: timedelta_div_timedelta procedure , private :: timedelta_eq procedure , private :: timedelta_neq procedure , private :: timedelta_gt procedure , private :: timedelta_ge procedure , private :: timedelta_lt procedure , private :: timedelta_le generic :: operator ( + ) => timedelta_plus_timedelta generic :: operator ( - ) => timedelta_minus_timedelta , unary_minus_timedelta generic :: operator ( / ) => timedelta_div_timedelta generic :: operator ( == ) => timedelta_eq generic :: operator ( /= ) => timedelta_neq generic :: operator ( > ) => timedelta_gt generic :: operator ( >= ) => timedelta_ge generic :: operator ( < ) => timedelta_lt generic :: operator ( <= ) => timedelta_le end type timedelta","tags":"","loc":"type/timedelta.html"},{"title":"datetime – time_manager ","text":"type, public :: datetime Inherited by type~~datetime~~InheritedByGraph type~datetime datetime type~clock clock type~clock->type~datetime strtTime, lastTime, Time, prevTime Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables calendar year month day hour minute second millisecond timezone Constructor datetime Type-Bound Procedures init isoformat timestamp format add_months add_days add_hours add_minutes add_seconds add_milliseconds days_in_month days_in_year ceiling_month ceiling_day assign add_timedelta sub_datetime sub_timedelta eq neq gt ge lt le assignment(=) operator(+) operator(-) operator(==) operator(/=) operator(>) operator(>=) operator( operator(<=) Source Code datetime Components Type Visibility Attributes Name Initial integer, public :: calendar = gregorian integer, public :: year = 1 integer, public :: month = 1 integer, public :: day = 1 integer, public :: hour = 0 integer, public :: minute = 0 integer, public :: second = 0 real(kind=8), public :: millisecond = 0 real(kind=8), public :: timezone = 0.0d0 Constructor public interface datetime initial function set to the same name with type private pure function create_datetime_1 (year, month, day, hour, minute, second, millisecond, julday, days, hours, minutes, seconds, timestamp, timezone, calendar) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: year integer, intent(in), optional :: month integer, intent(in), optional :: day integer, intent(in), optional :: hour integer, intent(in), optional :: minute integer, intent(in), optional :: second integer, intent(in), optional :: millisecond integer, intent(in), optional :: julday integer, intent(in), optional :: days integer, intent(in), optional :: hours integer, intent(in), optional :: minutes integer, intent(in), optional :: seconds class(*), intent(in), optional :: timestamp class(*), intent(in), optional :: timezone integer, intent(in), optional :: calendar Return Value type( datetime ) private function create_datetime_2 (datetime_str, format_str, timezone, calendar) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: datetime_str character(len=*), intent(in), optional :: format_str class(*), intent(in), optional :: timezone integer, intent(in), optional :: calendar Return Value type( datetime ) Type-Bound Procedures procedure, public :: init private subroutine init (this) Arguments Type Intent Optional Attributes Name class( datetime ), intent(inout) :: this procedure, public :: isoformat private function isoformat (this) result(res) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this Return Value character(len=:),\n  allocatable procedure, public :: timestamp private function timestamp (this, timezone) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this class(*), intent(in), optional :: timezone Return Value real(kind=8) procedure, public :: format private function format (this, format_str) result(res) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this character(len=*), intent(in) :: format_str Return Value character(len=:),\n  allocatable procedure, public :: add_months private pure subroutine add_months (this, months) Arguments Type Intent Optional Attributes Name class( datetime ), intent(inout) :: this integer, intent(in) :: months procedure, public :: add_days private pure subroutine add_days (this, days) Arguments Type Intent Optional Attributes Name class( datetime ), intent(inout) :: this class(*), intent(in) :: days procedure, public :: add_hours private pure subroutine add_hours (this, hours) Arguments Type Intent Optional Attributes Name class( datetime ), intent(inout) :: this class(*), intent(in) :: hours procedure, public :: add_minutes private pure subroutine add_minutes (this, minutes) Arguments Type Intent Optional Attributes Name class( datetime ), intent(inout) :: this class(*), intent(in) :: minutes procedure, public :: add_seconds private pure subroutine add_seconds (this, seconds) Arguments Type Intent Optional Attributes Name class( datetime ), intent(inout) :: this class(*), intent(in) :: seconds procedure, public :: add_milliseconds private pure subroutine add_milliseconds (this, milliseconds) Arguments Type Intent Optional Attributes Name class( datetime ), intent(inout) :: this class(*), intent(in) :: milliseconds procedure, public :: days_in_month private pure function days_in_month (this) result(res) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this Return Value real(kind=8) procedure, public :: days_in_year private pure function days_in_year (this) result(res) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this Return Value real(kind=8) procedure, public :: ceiling_month private pure function ceiling_month (this) result(res) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this Return Value type( datetime ) procedure, public :: ceiling_day private pure function ceiling_day (this) result(res) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this Return Value type( datetime ) procedure, private :: assign private pure elemental subroutine assign (this, other) Arguments Type Intent Optional Attributes Name class( datetime ), intent(inout) :: this class( datetime ), intent(in) :: other procedure, private :: add_timedelta private elemental function add_timedelta (this, td) result(res) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this type( timedelta ), intent(in) :: td Return Value type( datetime ) procedure, private :: sub_datetime private recursive function sub_datetime (this, other) result(res) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this class( datetime ), intent(in) :: other Return Value type( timedelta ) procedure, private :: sub_timedelta private pure elemental function sub_timedelta (this, td) result(res) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this type( timedelta ), intent(in) :: td Return Value type( datetime ) procedure, private :: eq private pure elemental function eq (this, other) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this class( datetime ), intent(in) :: other Return Value logical procedure, private :: neq private pure elemental function neq (this, other) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this class( datetime ), intent(in) :: other Return Value logical procedure, private :: gt private pure elemental function gt (this, other) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this class( datetime ), intent(in) :: other Return Value logical procedure, private :: ge private pure elemental function ge (this, other) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this class( datetime ), intent(in) :: other Return Value logical procedure, private :: lt private pure elemental function lt (this, other) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this class( datetime ), intent(in) :: other Return Value logical procedure, private :: le private pure elemental function le (this, other) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this class( datetime ), intent(in) :: other Return Value logical generic, public :: assignment(=) => assign private pure elemental subroutine assign (this, other) Arguments Type Intent Optional Attributes Name class( datetime ), intent(inout) :: this class( datetime ), intent(in) :: other generic, public :: operator(+) => add_timedelta private elemental function add_timedelta (this, td) result(res) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this type( timedelta ), intent(in) :: td Return Value type( datetime ) generic, public :: operator(-) => sub_datetime , sub_timedelta private recursive function sub_datetime (this, other) result(res) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this class( datetime ), intent(in) :: other Return Value type( timedelta ) private pure elemental function sub_timedelta (this, td) result(res) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this type( timedelta ), intent(in) :: td Return Value type( datetime ) generic, public :: operator(==) => eq private pure elemental function eq (this, other) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this class( datetime ), intent(in) :: other Return Value logical generic, public :: operator(/=) => neq private pure elemental function neq (this, other) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this class( datetime ), intent(in) :: other Return Value logical generic, public :: operator(>) => gt private pure elemental function gt (this, other) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this class( datetime ), intent(in) :: other Return Value logical generic, public :: operator(>=) => ge private pure elemental function ge (this, other) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this class( datetime ), intent(in) :: other Return Value logical generic, public :: operator(  => lt private pure elemental function lt (this, other) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this class( datetime ), intent(in) :: other Return Value logical generic, public :: operator(<=) => le private pure elemental function le (this, other) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this class( datetime ), intent(in) :: other Return Value logical Source Code type datetime integer :: calendar = gregorian integer :: year = 1 integer :: month = 1 integer :: day = 1 integer :: hour = 0 integer :: minute = 0 integer :: second = 0 real ( 8 ) :: millisecond = 0 real ( 8 ) :: timezone = 0.0d0 contains procedure :: init procedure :: isoformat procedure :: timestamp procedure :: format procedure :: add_months procedure :: add_days procedure :: add_hours procedure :: add_minutes procedure :: add_seconds procedure :: add_milliseconds procedure :: days_in_month procedure :: days_in_year procedure :: ceiling_month procedure :: ceiling_day procedure , private :: assign procedure , private :: add_timedelta procedure , private :: sub_datetime procedure , private :: sub_timedelta procedure , private :: eq procedure , private :: neq procedure , private :: gt procedure , private :: ge procedure , private :: lt procedure , private :: le generic :: assignment ( = ) => assign generic :: operator ( + ) => add_timedelta generic :: operator ( - ) => sub_datetime , sub_timedelta generic :: operator ( == ) => eq generic :: operator ( /= ) => neq generic :: operator ( > ) => gt generic :: operator ( >= ) => ge generic :: operator ( < ) => lt generic :: operator ( <= ) => le end type datetime","tags":"","loc":"type/datetime.html"},{"title":"clock – time_manager ","text":"type, public :: clock Inherits type~~clock~~InheritsGraph type~clock clock type~timedelta timedelta type~clock->type~timedelta dt type~datetime datetime type~clock->type~datetime strtTime, lastTime, Time, prevTime Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables strtTime lastTime Time prevTime dt started stopped alarm_d index_d axis_d alarm_m index_m axis_m Constructor clock Type-Bound Procedures reset tick Source Code clock Components Type Visibility Attributes Name Initial type( datetime ), public :: strtTime type( datetime ), public :: lastTime type( datetime ), public :: Time type( datetime ), public :: prevTime type( timedelta ), public :: dt logical, public :: started = .false. logical, public :: stopped = .false. logical, public :: alarm_d repeat alarm for daily integer, public :: index_d = 0 real(kind=8), public :: axis_d = 0.d0 logical, public :: alarm_m repeat alarm for monthly integer, public :: index_m = 0 real(kind=8), public :: axis_m = 0.d0 Constructor public interface clock initial function set to the same name with type private pure function create_clock (d0, d1, dt) result(res) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: d0 class( datetime ), intent(in) :: d1 class( timedelta ), intent(in) :: dt Return Value type( clock ) Type-Bound Procedures procedure, public :: reset private pure elemental subroutine reset (this) Arguments Type Intent Optional Attributes Name class( clock ), intent(inout) :: this procedure, public :: tick private pure elemental subroutine tick (this) alarm for daily\n alarm for monthly Arguments Type Intent Optional Attributes Name class( clock ), intent(inout) :: this Source Code type clock type ( datetime ) :: strtTime type ( datetime ) :: lastTime type ( datetime ) :: Time type ( datetime ) :: prevTime type ( timedelta ) :: dt logical :: started = . false . logical :: stopped = . false . logical :: alarm_d !! repeat alarm for daily integer :: index_d = 0 real ( 8 ) :: axis_d = 0.d0 logical :: alarm_m !! repeat alarm for monthly integer :: index_m = 0 real ( 8 ) :: axis_m = 0.d0 contains procedure :: reset procedure :: tick end type clock","tags":"","loc":"type/clock.html"},{"title":"create_clock – time_manager","text":"private pure function create_clock(d0, d1, dt) result(res) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: d0 class( datetime ), intent(in) :: d1 class( timedelta ), intent(in) :: dt Return Value type( clock ) Calls proc~~create_clock~~CallsGraph proc~create_clock create_clock interface~datetime datetime proc~create_clock->interface~datetime interface~timedelta timedelta proc~create_clock->interface~timedelta proc~create_datetime_1 create_datetime_1 interface~datetime->proc~create_datetime_1 proc~create_datetime_2 create_datetime_2 interface~datetime->proc~create_datetime_2 proc~create_timedelta create_timedelta interface~timedelta->proc~create_timedelta proc~accum_days accum_days proc~create_datetime_1->proc~accum_days proc~days_of_month days_of_month proc~create_datetime_1->proc~days_of_month proc~accum_days->proc~days_of_month proc~is_leap_year is_leap_year proc~days_of_month->proc~is_leap_year var panproccreate_clockCallsGraph = svgPanZoom('#proccreate_clockCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~create_clock~~CalledByGraph proc~create_clock create_clock interface~clock clock interface~clock->proc~create_clock Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code create_clock Source Code pure type ( clock ) function create_clock ( d0 , d1 , dt ) result ( res ) class ( datetime ), intent ( in ) :: d0 , d1 class ( timedelta ), intent ( in ) :: dt if ( d1 > d0 ) then res % strtTime = d0 res % Time = d0 res % lastTime = d1 res % dt = dt else res % strtTime = datetime ( 1980 , 1 , 1 , 0 , 0 , 0 ) res % Time = datetime ( 1980 , 1 , 1 , 0 , 0 , 0 ) res % lastTime = datetime ( 1981 , 1 , 1 , 0 , 0 , 0 ) res % dt = timedelta ( hours = 24 ) end if res % index_d = 0 res % index_m = 0 end function create_clock","tags":"","loc":"proc/create_clock.html"},{"title":"create_timedelta – time_manager","text":"private pure function create_timedelta(days, hours, minutes, seconds, milliseconds) result(res) Arguments Type Intent Optional Attributes Name class(*), intent(in), optional :: days class(*), intent(in), optional :: hours class(*), intent(in), optional :: minutes class(*), intent(in), optional :: seconds class(*), intent(in), optional :: milliseconds Return Value type( timedelta ) Called by proc~~create_timedelta~~CalledByGraph proc~create_timedelta create_timedelta interface~timedelta timedelta interface~timedelta->proc~create_timedelta proc~sub_datetime sub_datetime proc~sub_datetime->proc~create_timedelta proc~sub_datetime->proc~sub_datetime proc~create_clock create_clock proc~create_clock->interface~timedelta proc~timedelta_plus_timedelta timedelta_plus_timedelta proc~timedelta_plus_timedelta->interface~timedelta interface~clock clock interface~clock->proc~create_clock Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code create_timedelta Source Code pure type ( timedelta ) function create_timedelta ( days , hours , minutes , seconds , milliseconds ) result ( res ) class ( * ), intent ( in ), optional :: days class ( * ), intent ( in ), optional :: hours class ( * ), intent ( in ), optional :: minutes class ( * ), intent ( in ), optional :: seconds class ( * ), intent ( in ), optional :: milliseconds if ( present ( days )) then select type ( days ) type is ( integer ) res % days = days type is ( real ( 4 )) res % days = days type is ( real ( 8 )) res % days = days end select end if if ( present ( hours )) then select type ( hours ) type is ( integer ) res % hours = hours type is ( real ( 4 )) res % hours = hours type is ( real ( 8 )) res % hours = hours end select end if if ( present ( minutes )) then select type ( minutes ) type is ( integer ) res % minutes = minutes type is ( real ( 4 )) res % minutes = minutes type is ( real ( 8 )) res % minutes = minutes end select end if if ( present ( seconds )) then select type ( seconds ) type is ( integer ) res % seconds = seconds type is ( real ( 4 )) res % seconds = seconds type is ( real ( 8 )) res % seconds = seconds end select end if if ( present ( milliseconds )) then select type ( milliseconds ) type is ( integer ) res % milliseconds = milliseconds type is ( real ( 4 )) res % milliseconds = milliseconds type is ( real ( 8 )) res % milliseconds = milliseconds end select end if end function create_timedelta","tags":"","loc":"proc/create_timedelta.html"},{"title":"total_seconds – time_manager","text":"private pure function total_seconds(this) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: this Return Value real(kind=8) Contents Source Code total_seconds Source Code pure real ( 8 ) function total_seconds ( this ) class ( timedelta ), intent ( in ) :: this total_seconds = this % days * 86400 + this % hours * 3600 + this % minutes * 60 + this % seconds + this % milliseconds * 1.0d-3 end function total_seconds","tags":"","loc":"proc/total_seconds.html"},{"title":"total_minutes – time_manager","text":"private pure function total_minutes(this) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: this Return Value real(kind=8) Contents Source Code total_minutes Source Code pure real ( 8 ) function total_minutes ( this ) class ( timedelta ), intent ( in ) :: this total_minutes = this % days * 1440 + this % hours * 60 + this % minutes + ( this % seconds + this % milliseconds * 1.0d-3 ) / 6 0.0d0 end function total_minutes","tags":"","loc":"proc/total_minutes.html"},{"title":"total_hours – time_manager","text":"private pure function total_hours(this) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: this Return Value real(kind=8) Contents Source Code total_hours Source Code pure real ( 8 ) function total_hours ( this ) class ( timedelta ), intent ( in ) :: this total_hours = this % days * 24 + this % hours + ( this % minutes + ( this % seconds + this % milliseconds * 1.0d-3 ) / 6 0.0d0 ) / 6 0.0d0 end function total_hours","tags":"","loc":"proc/total_hours.html"},{"title":"total_days – time_manager","text":"private pure function total_days(this) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: this Return Value real(kind=8) Contents Source Code total_days Source Code pure real ( 8 ) function total_days ( this ) class ( timedelta ), intent ( in ) :: this total_days = this % days + ( this % hours + ( this % minutes + ( this % seconds + this % milliseconds * 1.0d-3 ) / 6 0.0d0 ) / 6 0.0d0 ) / 2 4.0d0 end function total_days","tags":"","loc":"proc/total_days.html"},{"title":"timedelta_plus_timedelta – time_manager","text":"private pure elemental function timedelta_plus_timedelta(t0, t1) result(t) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: t0 class( timedelta ), intent(in) :: t1 Return Value type( timedelta ) Calls proc~~timedelta_plus_timedelta~~CallsGraph proc~timedelta_plus_timedelta timedelta_plus_timedelta interface~timedelta timedelta proc~timedelta_plus_timedelta->interface~timedelta proc~create_timedelta create_timedelta interface~timedelta->proc~create_timedelta Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code timedelta_plus_timedelta Source Code pure elemental type ( timedelta ) function timedelta_plus_timedelta ( t0 , t1 ) result ( t ) ! Adds two `timedelta` instances together and returns a `timedelta` ! instance. Overloads the operator `+`. class ( timedelta ), intent ( in ) :: t0 , t1 t = timedelta ( days = t0 % days + t1 % days , & hours = t0 % hours + t1 % hours , & minutes = t0 % minutes + t1 % minutes , & seconds = t0 % seconds + t1 % seconds , & milliseconds = t0 % milliseconds + t1 % milliseconds ) end function timedelta_plus_timedelta","tags":"","loc":"proc/timedelta_plus_timedelta.html"},{"title":"timedelta_minus_timedelta – time_manager","text":"private pure elemental function timedelta_minus_timedelta(t0, t1) result(t) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: t0 class( timedelta ), intent(in) :: t1 Return Value type( timedelta ) Contents Source Code timedelta_minus_timedelta Source Code pure elemental type ( timedelta ) function timedelta_minus_timedelta ( t0 , t1 ) result ( t ) ! Subtracts a `timedelta` instance from another. Returns a ! `timedelta` instance. Overloads the operator `-`. class ( timedelta ), intent ( in ) :: t0 , t1 t = t0 + ( - t1 ) end function timedelta_minus_timedelta","tags":"","loc":"proc/timedelta_minus_timedelta.html"},{"title":"unary_minus_timedelta – time_manager","text":"private pure elemental function unary_minus_timedelta(t0) result(t) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: t0 Return Value type( timedelta ) Contents Source Code unary_minus_timedelta Source Code pure elemental type ( timedelta ) function unary_minus_timedelta ( t0 ) result ( t ) ! Takes a negative of a `timedelta` instance. Overloads the operator `-`. class ( timedelta ), intent ( in ) :: t0 t % days = - t0 % days t % hours = - t0 % hours t % minutes = - t0 % minutes t % seconds = - t0 % seconds t % milliseconds = - t0 % milliseconds end function unary_minus_timedelta","tags":"","loc":"proc/unary_minus_timedelta.html"},{"title":"timedelta_div_timedelta – time_manager","text":"private pure elemental function timedelta_div_timedelta(t0, t1) result(factor) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: t0 class( timedelta ), intent(in) :: t1 Return Value real(kind=8) Contents Source Code timedelta_div_timedelta Source Code pure elemental real ( 8 ) function timedelta_div_timedelta ( t0 , t1 ) result ( factor ) ! Divide two 'timedelta' instances and return a factor, ! Overloads the operator `/`. class ( timedelta ), intent ( in ) :: t0 , t1 factor = t0 % total_seconds () / t1 % total_seconds () end function timedelta_div_timedelta","tags":"","loc":"proc/timedelta_div_timedelta.html"},{"title":"timedelta_eq – time_manager","text":"private pure elemental function timedelta_eq(this, other) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: this class( timedelta ), intent(in) :: other Return Value logical Contents Source Code timedelta_eq Source Code pure elemental logical function timedelta_eq ( this , other ) class ( timedelta ), intent ( in ) :: this class ( timedelta ), intent ( in ) :: other timedelta_eq = this % total_seconds () == other % total_seconds () end function timedelta_eq","tags":"","loc":"proc/timedelta_eq.html"},{"title":"timedelta_neq – time_manager","text":"private pure elemental function timedelta_neq(this, other) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: this class( timedelta ), intent(in) :: other Return Value logical Contents Source Code timedelta_neq Source Code pure elemental logical function timedelta_neq ( this , other ) class ( timedelta ), intent ( in ) :: this class ( timedelta ), intent ( in ) :: other timedelta_neq = this % total_seconds () /= other % total_seconds () end function timedelta_neq","tags":"","loc":"proc/timedelta_neq.html"},{"title":"timedelta_gt – time_manager","text":"private pure elemental function timedelta_gt(this, other) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: this class( timedelta ), intent(in) :: other Return Value logical Contents Source Code timedelta_gt Source Code pure elemental logical function timedelta_gt ( this , other ) class ( timedelta ), intent ( in ) :: this class ( timedelta ), intent ( in ) :: other timedelta_gt = this % total_seconds () > other % total_seconds () end function timedelta_gt","tags":"","loc":"proc/timedelta_gt.html"},{"title":"timedelta_ge – time_manager","text":"private pure elemental function timedelta_ge(this, other) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: this class( timedelta ), intent(in) :: other Return Value logical Contents Source Code timedelta_ge Source Code pure elemental logical function timedelta_ge ( this , other ) class ( timedelta ), intent ( in ) :: this class ( timedelta ), intent ( in ) :: other timedelta_ge = this % total_seconds () >= other % total_seconds () end function timedelta_ge","tags":"","loc":"proc/timedelta_ge.html"},{"title":"timedelta_lt – time_manager","text":"private pure elemental function timedelta_lt(this, other) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: this class( timedelta ), intent(in) :: other Return Value logical Contents Source Code timedelta_lt Source Code pure elemental logical function timedelta_lt ( this , other ) class ( timedelta ), intent ( in ) :: this class ( timedelta ), intent ( in ) :: other timedelta_lt = this % total_seconds () < other % total_seconds () end function timedelta_lt","tags":"","loc":"proc/timedelta_lt.html"},{"title":"timedelta_le – time_manager","text":"private pure elemental function timedelta_le(this, other) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: this class( timedelta ), intent(in) :: other Return Value logical Contents Source Code timedelta_le Source Code pure elemental logical function timedelta_le ( this , other ) class ( timedelta ), intent ( in ) :: this class ( timedelta ), intent ( in ) :: other timedelta_le = this % total_seconds () <= other % total_seconds () end function timedelta_le","tags":"","loc":"proc/timedelta_le.html"},{"title":"create_datetime_1 – time_manager","text":"private pure function create_datetime_1(year, month, day, hour, minute, second, millisecond, julday, days, hours, minutes, seconds, timestamp, timezone, calendar) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: year integer, intent(in), optional :: month integer, intent(in), optional :: day integer, intent(in), optional :: hour integer, intent(in), optional :: minute integer, intent(in), optional :: second integer, intent(in), optional :: millisecond integer, intent(in), optional :: julday integer, intent(in), optional :: days integer, intent(in), optional :: hours integer, intent(in), optional :: minutes integer, intent(in), optional :: seconds class(*), intent(in), optional :: timestamp class(*), intent(in), optional :: timezone integer, intent(in), optional :: calendar Return Value type( datetime ) Calls proc~~create_datetime_1~~CallsGraph proc~create_datetime_1 create_datetime_1 proc~accum_days accum_days proc~create_datetime_1->proc~accum_days proc~days_of_month days_of_month proc~create_datetime_1->proc~days_of_month proc~accum_days->proc~days_of_month proc~is_leap_year is_leap_year proc~days_of_month->proc~is_leap_year Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~create_datetime_1~~CalledByGraph proc~create_datetime_1 create_datetime_1 interface~datetime datetime interface~datetime->proc~create_datetime_1 proc~ceiling_day ceiling_day proc~ceiling_day->interface~datetime proc~create_clock create_clock proc~create_clock->interface~datetime proc~ceiling_month ceiling_month proc~ceiling_month->interface~datetime proc~timestamp timestamp proc~timestamp->interface~datetime interface~clock clock interface~clock->proc~create_clock Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code create_datetime_1 Source Code pure type ( datetime ) function create_datetime_1 ( & year , month , day , hour , minute , second , millisecond , & julday , days , hours , minutes , seconds , & timestamp , & timezone , calendar ) result ( res ) integer , intent ( in ), optional :: year integer , intent ( in ), optional :: month integer , intent ( in ), optional :: day integer , intent ( in ), optional :: hour integer , intent ( in ), optional :: minute integer , intent ( in ), optional :: second integer , intent ( in ), optional :: millisecond integer , intent ( in ), optional :: julday integer , intent ( in ), optional :: days integer , intent ( in ), optional :: hours integer , intent ( in ), optional :: minutes integer , intent ( in ), optional :: seconds class ( * ), intent ( in ), optional :: timestamp class ( * ), intent ( in ), optional :: timezone integer , intent ( in ), optional :: calendar real ( 8 ) residue_seconds integer mon if ( present ( calendar )) res % calendar = calendar if ( present ( timestamp )) then ! Assume the start date time is UTC 0001-01-01 00:00:00 defined default_year, default_units res % year = default_year res % month = 1 res % day = 1 res % hour = 0 res % minute = 0 res % second = 0 res % millisecond = 0 select type ( timestamp ) type is ( integer ) residue_seconds = timestamp type is ( real ( 4 )) residue_seconds = timestamp type is ( real ( 8 )) residue_seconds = timestamp end select call res % add_days ( int ( residue_seconds / 8640 0.0 )) residue_seconds = mod ( residue_seconds , 8640 0.0 ) call res % add_hours ( int ( residue_seconds / 360 0.0 )) residue_seconds = mod ( residue_seconds , 360 0.0 ) call res % add_minutes ( int ( residue_seconds / 6 0.0 )) residue_seconds = mod ( residue_seconds , 6 0.0 ) call res % add_seconds ( int ( residue_seconds )) call res % add_milliseconds (( residue_seconds - int ( residue_seconds )) * 1000 ) else if ( present ( year )) res % year = year if ( present ( julday )) then res % day = 0 do mon = 1 , 12 res % day = res % day + days_of_month ( year , mon , res % calendar ) if ( res % day > julday ) exit end do res % month = min ( mon , 12 ) res % day = julday - accum_days ( year , res % month , 0 , res % calendar ) else if ( present ( month )) res % month = month if ( present ( day )) res % day = day end if if ( present ( hour )) res % hour = hour if ( present ( minute )) res % minute = minute if ( present ( second )) res % second = second if ( present ( millisecond )) res % millisecond = millisecond if ( present ( days )) call res % add_days ( days ) if ( present ( hours )) call res % add_hours ( hours ) if ( present ( minutes )) call res % add_minutes ( minutes ) if ( present ( seconds )) call res % add_seconds ( seconds ) if ( res % second == 60 ) then call res % add_minutes ( 1 ) res % second = 0 end if if ( res % minute == 60 ) then call res % add_hours ( 1 ) res % minute = 0 end if if ( res % hour == 24 ) then call res % add_days ( 1 ) res % hour = 0 end if end if if ( present ( timezone )) then select type ( timezone ) type is ( integer ) res % timezone = timezone type is ( real ( 4 )) res % timezone = timezone type is ( real ( 8 )) res % timezone = timezone end select end if end function create_datetime_1","tags":"","loc":"proc/create_datetime_1.html"},{"title":"create_datetime_2 – time_manager","text":"private function create_datetime_2(datetime_str, format_str, timezone, calendar) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: datetime_str character(len=*), intent(in), optional :: format_str class(*), intent(in), optional :: timezone integer, intent(in), optional :: calendar Return Value type( datetime ) Called by proc~~create_datetime_2~~CalledByGraph proc~create_datetime_2 create_datetime_2 interface~datetime datetime interface~datetime->proc~create_datetime_2 proc~ceiling_day ceiling_day proc~ceiling_day->interface~datetime proc~create_clock create_clock proc~create_clock->interface~datetime proc~ceiling_month ceiling_month proc~ceiling_month->interface~datetime proc~timestamp timestamp proc~timestamp->interface~datetime interface~clock clock interface~clock->proc~create_clock Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code create_datetime_2 Source Code type ( datetime ) function create_datetime_2 ( datetime_str , format_str , timezone , calendar ) result ( res ) character ( * ), intent ( in ) :: datetime_str character ( * ), intent ( in ), optional :: format_str class ( * ), intent ( in ), optional :: timezone integer , intent ( in ), optional :: calendar integer i , j , num_spec character ( 1 ), allocatable :: specs (:) ! Date time element specifiers (e.g. 'Y', 'm', 'd') if ( present ( format_str )) then num_spec = 0 i = 1 do while ( i <= len_trim ( format_str )) if ( format_str ( i : i ) == '%' ) then ! % character consumes 1 character specifier. num_spec = num_spec + 1 i = i + 2 else i = i + 1 end if end do allocate ( specs ( num_spec )) i = 1 j = 1 do while ( i <= len_trim ( format_str )) if ( format_str ( i : i ) == '%' ) then i = i + 1 select case ( format_str ( i : i )) case ( 'Y' ) read ( datetime_str ( j : j + 3 ), '(I4)' ) res % year j = j + 4 case ( 'm' ) read ( datetime_str ( j : j + 1 ), '(I2)' ) res % month j = j + 2 case ( 'd' ) read ( datetime_str ( j : j + 1 ), '(I2)' ) res % day j = j + 2 case ( 'H' ) read ( datetime_str ( j : j + 1 ), '(I2)' ) res % hour j = j + 2 case ( 'M' ) read ( datetime_str ( j : j + 1 ), '(I2)' ) res % minute j = j + 2 case ( 'S' ) read ( datetime_str ( j : j + 1 ), '(I2)' ) res % second j = j + 2 case default j = j + 1 end select else j = j + 1 end if i = i + 1 end do else ! TODO: I assume UTC time for the time being. read ( datetime_str ( 1 : 4 ), '(I4)' ) res % year read ( datetime_str ( 6 : 7 ), '(I2)' ) res % month read ( datetime_str ( 9 : 10 ), '(I2)' ) res % day read ( datetime_str ( 12 : 13 ), '(I2)' ) res % hour read ( datetime_str ( 15 : 16 ), '(I2)' ) res % minute read ( datetime_str ( 18 : 19 ), '(I2)' ) res % second end if if ( present ( timezone )) then select type ( timezone ) type is ( integer ) res % timezone = timezone type is ( real ( 4 )) res % timezone = timezone type is ( real ( 8 )) res % timezone = timezone class default write ( * , * ) '[Error]: datetime: Invalid timezone argument type! Only integer and real are supported.' stop 1 end select end if if ( present ( calendar )) res % calendar = calendar end function create_datetime_2","tags":"","loc":"proc/create_datetime_2.html"},{"title":"isoformat – time_manager","text":"private function isoformat(this) result(res) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this Return Value character(len=:),\n  allocatable Contents Source Code isoformat Source Code function isoformat ( this ) result ( res ) class ( datetime ), intent ( in ) :: this character (:), allocatable :: res character ( 30 ) tmp if ( this % timezone == 0 ) then write ( tmp , \"(I4.4, '-', I2.2, '-', I2.2, 'T', I2.2, ':', I2.2, ':', I2.2, 'Z')\" ) & this % year , this % month , this % day , this % hour , this % minute , this % second else write ( tmp , \"(I4.4, '-', I2.2, '-', I2.2, 'T', I2.2, ':', I2.2, ':', I2.2, SP, I3.2, ':00')\" ) & this % year , this % month , this % day , this % hour , this % minute , this % second , int ( this % timezone ) end if res = trim ( tmp ) end function isoformat","tags":"","loc":"proc/isoformat.html"},{"title":"timestamp – time_manager","text":"private function timestamp(this, timezone) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this class(*), intent(in), optional :: timezone Return Value real(kind=8) Calls proc~~timestamp~~CallsGraph proc~timestamp timestamp interface~datetime datetime proc~timestamp->interface~datetime proc~create_datetime_1 create_datetime_1 interface~datetime->proc~create_datetime_1 proc~create_datetime_2 create_datetime_2 interface~datetime->proc~create_datetime_2 proc~accum_days accum_days proc~create_datetime_1->proc~accum_days proc~days_of_month days_of_month proc~create_datetime_1->proc~days_of_month proc~accum_days->proc~days_of_month proc~is_leap_year is_leap_year proc~days_of_month->proc~is_leap_year Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code timestamp Source Code function timestamp ( this , timezone ) class ( datetime ), intent ( in ) :: this class ( * ), intent ( in ), optional :: timezone real ( 8 ) timestamp type ( timedelta ) dt dt = this - datetime ( default_year ) timestamp = dt % total_days () if ( present ( timezone )) then select type ( timezone ) type is ( integer ) timestamp = timestamp - ( this % timezone - timezone ) / 2 4.d0 type is ( real ( 4 )) timestamp = timestamp - ( this % timezone - timezone ) / 2 4.d0 type is ( real ( 8 )) timestamp = timestamp - ( this % timezone - timezone ) / 2 4.d0 end select end if end function timestamp","tags":"","loc":"proc/timestamp.html"},{"title":"format – time_manager","text":"private function format(this, format_str) result(res) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this character(len=*), intent(in) :: format_str Return Value character(len=:),\n  allocatable Contents Source Code format Source Code function format ( this , format_str ) result ( res ) class ( datetime ), intent ( in ) :: this character ( * ), intent ( in ) :: format_str character (:), allocatable :: res character ( 100 ) tmp integer i , j tmp = '' i = 1 j = 1 do while ( i <= len_trim ( format_str )) if ( format_str ( i : i ) == '%' ) then i = i + 1 select case ( format_str ( i : i )) case ( 'Y' ) write ( tmp ( j : j + 3 ), '(I4.4)' ) this % year j = j + 4 case ( 'y' ) write ( tmp ( j : j + 1 ), '(I2.2)' ) mod ( this % year , 100 ) j = j + 2 case ( 'j' ) write ( tmp ( j : j + 2 ), '(I3.3)' ) int ( this % days_in_year ()) j = j + 3 case ( 'm' ) write ( tmp ( j : j + 1 ), '(I2.2)' ) this % month j = j + 2 case ( 'd' ) write ( tmp ( j : j + 1 ), '(I2.2)' ) this % day j = j + 2 case ( 'H' ) write ( tmp ( j : j + 1 ), '(I2.2)' ) this % hour j = j + 2 case ( 'M' ) write ( tmp ( j : j + 1 ), '(I2.2)' ) this % minute j = j + 2 case ( 'S' ) write ( tmp ( j : j + 1 ), '(I2.2)' ) this % second j = j + 2 case ( 's' ) write ( tmp ( j : j + 4 ), '(I5.5)' ) this % hour * 3600 + this % minute * 60 + this % second end select else write ( tmp ( j : j ), '(A1)' ) format_str ( i : i ) j = j + 1 end if i = i + 1 end do res = trim ( tmp ) end function format","tags":"","loc":"proc/format.html"},{"title":"ceiling_day – time_manager","text":"private pure function ceiling_day(this) result(res) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this Return Value type( datetime ) Calls proc~~ceiling_day~~CallsGraph proc~ceiling_day ceiling_day interface~datetime datetime proc~ceiling_day->interface~datetime proc~create_datetime_1 create_datetime_1 interface~datetime->proc~create_datetime_1 proc~create_datetime_2 create_datetime_2 interface~datetime->proc~create_datetime_2 proc~accum_days accum_days proc~create_datetime_1->proc~accum_days proc~days_of_month days_of_month proc~create_datetime_1->proc~days_of_month proc~accum_days->proc~days_of_month proc~is_leap_year is_leap_year proc~days_of_month->proc~is_leap_year var panprocceiling_dayCallsGraph = svgPanZoom('#procceiling_dayCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code ceiling_day Source Code pure type ( datetime ) function ceiling_day ( this ) result ( res ) class ( datetime ), intent ( in ) :: this res = datetime ( this % year , this % month , this % day , 0 , 0 , 0 , calendar = this % calendar ) call res % add_days ( 1 ) return end function ceiling_day","tags":"","loc":"proc/ceiling_day.html"},{"title":"ceiling_month – time_manager","text":"private pure function ceiling_month(this) result(res) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this Return Value type( datetime ) Calls proc~~ceiling_month~~CallsGraph proc~ceiling_month ceiling_month interface~datetime datetime proc~ceiling_month->interface~datetime proc~create_datetime_1 create_datetime_1 interface~datetime->proc~create_datetime_1 proc~create_datetime_2 create_datetime_2 interface~datetime->proc~create_datetime_2 proc~accum_days accum_days proc~create_datetime_1->proc~accum_days proc~days_of_month days_of_month proc~create_datetime_1->proc~days_of_month proc~accum_days->proc~days_of_month proc~is_leap_year is_leap_year proc~days_of_month->proc~is_leap_year var panprocceiling_monthCallsGraph = svgPanZoom('#procceiling_monthCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code ceiling_month Source Code pure type ( datetime ) function ceiling_month ( this ) result ( res ) class ( datetime ), intent ( in ) :: this res = datetime ( this % year , this % month , 1 , 0 , 0 , 0 , calendar = this % calendar ) call res % add_months ( 1 ) return end function ceiling_month","tags":"","loc":"proc/ceiling_month.html"},{"title":"days_in_month – time_manager","text":"private pure function days_in_month(this) result(res) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this Return Value real(kind=8) Contents Source Code days_in_month Source Code pure real ( 8 ) function days_in_month ( this ) result ( res ) class ( datetime ), intent ( in ) :: this res = this % day + this % hour / 2 4.0d0 + this % minute / 2 4.0d0 / 60 + this % second / 2 4.0d0 / 3600 + this % millisecond / 2 4.0d0 / 3600 / 1000 end function days_in_month","tags":"","loc":"proc/days_in_month.html"},{"title":"days_in_year – time_manager","text":"private pure function days_in_year(this) result(res) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this Return Value real(kind=8) Calls proc~~days_in_year~~CallsGraph proc~days_in_year days_in_year proc~days_of_month days_of_month proc~days_in_year->proc~days_of_month proc~is_leap_year is_leap_year proc~days_of_month->proc~is_leap_year Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code days_in_year Source Code pure real ( 8 ) function days_in_year ( this ) result ( res ) class ( datetime ), intent ( in ) :: this integer month res = 0 do month = 1 , this % month - 1 res = res + days_of_month ( this % year , month , this % calendar ) end do res = res + this % days_in_month () end function days_in_year","tags":"","loc":"proc/days_in_year.html"},{"title":"add_timedelta – time_manager","text":"private elemental function add_timedelta(this, td) result(res) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this type( timedelta ), intent(in) :: td Return Value type( datetime ) Contents Source Code add_timedelta Source Code elemental type ( datetime ) function add_timedelta ( this , td ) result ( res ) class ( datetime ), intent ( in ) :: this type ( timedelta ), intent ( in ) :: td res = this call res % add_milliseconds ( td % milliseconds ) call res % add_seconds ( td % seconds ) call res % add_minutes ( td % minutes ) call res % add_hours ( td % hours ) call res % add_days ( td % days ) end function add_timedelta","tags":"","loc":"proc/add_timedelta.html"},{"title":"sub_timedelta – time_manager","text":"private pure elemental function sub_timedelta(this, td) result(res) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this type( timedelta ), intent(in) :: td Return Value type( datetime ) Contents Source Code sub_timedelta Source Code pure elemental type ( datetime ) function sub_timedelta ( this , td ) result ( res ) class ( datetime ), intent ( in ) :: this type ( timedelta ), intent ( in ) :: td res = this call res % add_milliseconds ( - td % milliseconds ) call res % add_seconds ( - td % seconds ) call res % add_minutes ( - td % minutes ) call res % add_hours ( - td % hours ) call res % add_days ( - td % days ) end function sub_timedelta","tags":"","loc":"proc/sub_timedelta.html"},{"title":"sub_datetime – time_manager","text":"private recursive function sub_datetime(this, other) result(res) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this class( datetime ), intent(in) :: other Return Value type( timedelta ) Calls proc~~sub_datetime~~CallsGraph proc~sub_datetime sub_datetime proc~sub_datetime->proc~sub_datetime proc~create_timedelta create_timedelta proc~sub_datetime->proc~create_timedelta proc~days_of_month days_of_month proc~sub_datetime->proc~days_of_month proc~is_leap_year is_leap_year proc~sub_datetime->proc~is_leap_year proc~days_of_month->proc~is_leap_year Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code sub_datetime Source Code type ( timedelta ) recursive function sub_datetime ( this , other ) result ( res ) class ( datetime ), intent ( in ) :: this class ( datetime ), intent ( in ) :: other integer year , month , days , hours , minutes , seconds real ( 8 ) milliseconds days = 0 hours = 0 minutes = 0 seconds = 0 milliseconds = 0 if ( this >= other ) then if ( this % year == other % year ) then if ( this % month == other % month ) then if ( this % day == other % day ) then if ( this % hour == other % hour ) then if ( this % minute == other % minute ) then if ( this % second == other % second ) then milliseconds = milliseconds + this % millisecond - other % millisecond else seconds = seconds + this % second - other % second - 1 milliseconds = milliseconds + 1000 - other % millisecond milliseconds = milliseconds + this % millisecond end if else minutes = minutes + this % minute - other % minute - 1 seconds = seconds + 60 - other % second - 1 seconds = seconds + this % second milliseconds = milliseconds + 1000 - other % millisecond milliseconds = milliseconds + this % millisecond end if else hours = hours + this % hour - other % hour - 1 minutes = minutes + 60 - other % minute - 1 minutes = minutes + this % minute seconds = seconds + 60 - other % second - 1 seconds = seconds + this % second milliseconds = milliseconds + 1000 - other % millisecond milliseconds = milliseconds + this % millisecond end if else days = days + this % day - other % day - 1 hours = hours + 24 - other % hour - 1 hours = hours + this % hour minutes = minutes + 60 - other % minute - 1 minutes = minutes + this % minute seconds = seconds + 60 - other % second - 1 seconds = seconds + this % second milliseconds = milliseconds + 1000 - other % millisecond milliseconds = milliseconds + this % millisecond end if else do month = other % month + 1 , this % month - 1 days = days + days_of_month ( this % year , month , this % calendar ) end do days = days + days_of_month ( other % year , other % month , other % calendar ) - other % day - 1 days = days + this % day hours = hours + 24 - other % hour - 1 hours = hours + this % hour minutes = minutes + 60 - other % minute - 1 minutes = minutes + this % minute seconds = seconds + 60 - other % second - 1 seconds = seconds + this % second milliseconds = milliseconds + 1000 - other % millisecond milliseconds = milliseconds + this % millisecond end if else do year = other % year + 1 , this % year - 1 if ( this % calendar == gregorian ) then days = days + 365 + merge ( 1 , 0 , is_leap_year ( year )) else days = days + 365 end if end do do month = other % month + 1 , 12 days = days + days_of_month ( other % year , month , other % calendar ) end do do month = 1 , this % month - 1 days = days + days_of_month ( this % year , month , this % calendar ) end do days = days + days_of_month ( other % year , other % month , other % calendar ) - other % day - 1 days = days + this % day hours = hours + 24 - other % hour - 1 hours = hours + this % hour minutes = minutes + 60 - other % minute - 1 minutes = minutes + this % minute seconds = seconds + 60 - other % second - 1 seconds = seconds + this % second milliseconds = milliseconds + 1000 - other % millisecond milliseconds = milliseconds + this % millisecond end if ! Carry over. if ( milliseconds >= 1000 ) then milliseconds = milliseconds - 1000 seconds = seconds + 1 end if if ( seconds >= 60 ) then seconds = seconds - 60 minutes = minutes + 1 end if if ( minutes >= 60 ) then minutes = minutes - 60 hours = hours + 1 end if if ( hours >= 24 ) then hours = hours - 24 days = days + 1 end if res = create_timedelta ( days = days , hours = hours , minutes = minutes , seconds = seconds , milliseconds = milliseconds ) else res = - sub_datetime ( other , this ) end if end function sub_datetime","tags":"","loc":"proc/sub_datetime.html"},{"title":"eq – time_manager","text":"private pure elemental function eq(this, other) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this class( datetime ), intent(in) :: other Return Value logical Contents Source Code eq Source Code pure elemental logical function eq ( this , other ) class ( datetime ), intent ( in ) :: this class ( datetime ), intent ( in ) :: other eq = this % year == other % year . and . & this % month == other % month . and . & this % day == other % day . and . & this % hour == other % hour . and . & this % minute == other % minute . and . & this % second == other % second . and . & this % millisecond == other % millisecond end function eq","tags":"","loc":"proc/eq.html"},{"title":"neq – time_manager","text":"private pure elemental function neq(this, other) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this class( datetime ), intent(in) :: other Return Value logical Contents Source Code neq Source Code pure elemental logical function neq ( this , other ) class ( datetime ), intent ( in ) :: this class ( datetime ), intent ( in ) :: other neq = . not . this == other end function neq","tags":"","loc":"proc/neq.html"},{"title":"gt – time_manager","text":"private pure elemental function gt(this, other) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this class( datetime ), intent(in) :: other Return Value logical Contents Source Code gt Source Code pure elemental logical function gt ( this , other ) class ( datetime ), intent ( in ) :: this class ( datetime ), intent ( in ) :: other if ( this % year < other % year ) then gt = . false . return else if ( this % year > other % year ) then gt = . true . return end if if ( this % month < other % month ) then gt = . false . return else if ( this % month > other % month ) then gt = . true . return end if if ( this % day < other % day ) then gt = . false . return else if ( this % day > other % day ) then gt = . true . return end if if ( this % hour < other % hour ) then gt = . false . return else if ( this % hour > other % hour ) then gt = . true . return end if if ( this % minute < other % minute ) then gt = . false . return else if ( this % minute > other % minute ) then gt = . true . return end if if ( this % second < other % second ) then gt = . false . return else if ( this % second > other % second ) then gt = . true . return end if if ( this % millisecond < other % millisecond ) then gt = . false . return else if ( this % millisecond < other % millisecond ) then gt = . true . return end if gt = this /= other end function gt","tags":"","loc":"proc/gt.html"},{"title":"ge – time_manager","text":"private pure elemental function ge(this, other) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this class( datetime ), intent(in) :: other Return Value logical Contents Source Code ge Source Code pure elemental logical function ge ( this , other ) class ( datetime ), intent ( in ) :: this class ( datetime ), intent ( in ) :: other ge = this > other . or . this == other end function ge","tags":"","loc":"proc/ge.html"},{"title":"lt – time_manager","text":"private pure elemental function lt(this, other) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this class( datetime ), intent(in) :: other Return Value logical Contents Source Code lt Source Code pure elemental logical function lt ( this , other ) class ( datetime ), intent ( in ) :: this class ( datetime ), intent ( in ) :: other lt = other > this end function lt","tags":"","loc":"proc/lt.html"},{"title":"le – time_manager","text":"private pure elemental function le(this, other) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this class( datetime ), intent(in) :: other Return Value logical Contents Source Code le Source Code pure elemental logical function le ( this , other ) class ( datetime ), intent ( in ) :: this class ( datetime ), intent ( in ) :: other le = other > this . or . this == other end function le","tags":"","loc":"proc/le.html"},{"title":"days_of_month – time_manager","text":"public pure function days_of_month(year, month, calendar) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: year integer, intent(in) :: month integer, intent(in) :: calendar Return Value integer Calls proc~~days_of_month~~CallsGraph proc~days_of_month days_of_month proc~is_leap_year is_leap_year proc~days_of_month->proc~is_leap_year Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~days_of_month~~CalledByGraph proc~days_of_month days_of_month proc~add_days add_days proc~add_days->proc~days_of_month proc~days_in_year days_in_year proc~days_in_year->proc~days_of_month proc~sub_datetime sub_datetime proc~sub_datetime->proc~days_of_month proc~sub_datetime->proc~sub_datetime proc~create_datetime_1 create_datetime_1 proc~create_datetime_1->proc~days_of_month proc~accum_days accum_days proc~create_datetime_1->proc~accum_days proc~accum_days->proc~days_of_month interface~datetime datetime interface~datetime->proc~create_datetime_1 proc~ceiling_day ceiling_day proc~ceiling_day->interface~datetime proc~create_clock create_clock proc~create_clock->interface~datetime proc~ceiling_month ceiling_month proc~ceiling_month->interface~datetime proc~timestamp timestamp proc~timestamp->interface~datetime interface~clock clock interface~clock->proc~create_clock var panprocdays_of_monthCalledByGraph = svgPanZoom('#procdays_of_monthCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code days_of_month Source Code pure integer function days_of_month ( year , month , calendar ) result ( res ) integer , intent ( in ) :: year integer , intent ( in ) :: month integer , intent ( in ) :: calendar integer , parameter :: days ( 12 ) = [ 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] if ( month == 2 . and . is_leap_year ( year ) . and . calendar == gregorian ) then res = 29 else res = days ( month ) end if end function days_of_month","tags":"","loc":"proc/days_of_month.html"},{"title":"accum_days – time_manager","text":"public pure function accum_days(year, month, day, calendar) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: year integer, intent(in) :: month integer, intent(in) :: day integer, intent(in) :: calendar Return Value integer Calls proc~~accum_days~~CallsGraph proc~accum_days accum_days proc~days_of_month days_of_month proc~accum_days->proc~days_of_month proc~is_leap_year is_leap_year proc~days_of_month->proc~is_leap_year Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~accum_days~~CalledByGraph proc~accum_days accum_days proc~create_datetime_1 create_datetime_1 proc~create_datetime_1->proc~accum_days interface~datetime datetime interface~datetime->proc~create_datetime_1 proc~ceiling_day ceiling_day proc~ceiling_day->interface~datetime proc~create_clock create_clock proc~create_clock->interface~datetime proc~ceiling_month ceiling_month proc~ceiling_month->interface~datetime proc~timestamp timestamp proc~timestamp->interface~datetime interface~clock clock interface~clock->proc~create_clock Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code accum_days Source Code pure integer function accum_days ( year , month , day , calendar ) result ( res ) integer , intent ( in ) :: year integer , intent ( in ) :: month integer , intent ( in ) :: day integer , intent ( in ) :: calendar integer mon res = day do mon = 1 , month - 1 res = res + days_of_month ( year , mon , calendar ) end do end function accum_days","tags":"","loc":"proc/accum_days.html"},{"title":"days_of_year – time_manager","text":"public pure function days_of_year(year, calendar) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: year integer, intent(in) :: calendar Return Value integer Calls proc~~days_of_year~~CallsGraph proc~days_of_year days_of_year proc~is_leap_year is_leap_year proc~days_of_year->proc~is_leap_year Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code days_of_year Source Code pure integer function days_of_year ( year , calendar ) result ( res ) integer , intent ( in ) :: year integer , intent ( in ) :: calendar select case ( calendar ) case ( gregorian ) if ( is_leap_year ( year )) then res = 366 else res = 365 end if case ( noleap ) res = 365 end select end function days_of_year","tags":"","loc":"proc/days_of_year.html"},{"title":"is_leap_year – time_manager","text":"public pure function is_leap_year(year) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: year Return Value logical Called by proc~~is_leap_year~~CalledByGraph proc~is_leap_year is_leap_year proc~days_of_year days_of_year proc~days_of_year->proc~is_leap_year proc~days_of_month days_of_month proc~days_of_month->proc~is_leap_year proc~sub_datetime sub_datetime proc~sub_datetime->proc~is_leap_year proc~sub_datetime->proc~days_of_month proc~sub_datetime->proc~sub_datetime proc~create_datetime_1 create_datetime_1 proc~create_datetime_1->proc~days_of_month proc~accum_days accum_days proc~create_datetime_1->proc~accum_days proc~add_days add_days proc~add_days->proc~days_of_month proc~accum_days->proc~days_of_month proc~days_in_year days_in_year proc~days_in_year->proc~days_of_month interface~datetime datetime interface~datetime->proc~create_datetime_1 proc~ceiling_day ceiling_day proc~ceiling_day->interface~datetime proc~create_clock create_clock proc~create_clock->interface~datetime proc~ceiling_month ceiling_month proc~ceiling_month->interface~datetime proc~timestamp timestamp proc~timestamp->interface~datetime interface~clock clock interface~clock->proc~create_clock var panprocis_leap_yearCalledByGraph = svgPanZoom('#procis_leap_yearCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code is_leap_year Source Code pure logical function is_leap_year ( year ) result ( res ) integer , intent ( in ) :: year res = ( mod ( year , 4 ) == 0 . and . . not . mod ( year , 100 ) == 0 ) . or . ( mod ( year , 400 ) == 0 ) end function is_leap_year","tags":"","loc":"proc/is_leap_year.html"},{"title":"reset – time_manager","text":"private pure elemental subroutine reset(this) Arguments Type Intent Optional Attributes Name class( clock ), intent(inout) :: this Contents Source Code reset Source Code pure elemental subroutine reset ( this ) ! Resets the clock to its start time. class ( clock ), intent ( in out ) :: this this % Time = this % strtTime this % started = . false . this % stopped = . false . end subroutine reset","tags":"","loc":"proc/reset.html"},{"title":"tick – time_manager","text":"private pure elemental subroutine tick(this) alarm for daily\n alarm for monthly Arguments Type Intent Optional Attributes Name class( clock ), intent(inout) :: this Contents Source Code tick Source Code pure elemental subroutine tick ( this ) ! Increments the Time of the clock instance by one dt. class ( clock ), intent ( inout ) :: this if ( this % stopped ) return if ( . not . this % started ) then this % started = . true . this % Time = this % strtTime end if this % prevTime = this % Time this % Time = this % prevTime + this % dt !! alarm for daily if ( this % Time >= this % prevTime % ceiling_day () ) then this % alarm_d = . true . this % index_d = this % index_d + 1 this % axis_d = this % Time % timestamp () - 1 else this % alarm_d = . false . end if !! alarm for monthly if ( this % Time >= this % prevTime % ceiling_month () ) then this % alarm_m = . true . this % index_m = this % index_m + 1 this % axis_m = this % Time % timestamp () - int ( this % prevTime % days_in_month ()) else this % alarm_m = . false . end if if ( this % Time >= this % lastTime ) this % stopped = . true . return end subroutine tick","tags":"","loc":"proc/tick.html"},{"title":"init – time_manager","text":"private subroutine init(this) Arguments Type Intent Optional Attributes Name class( datetime ), intent(inout) :: this Contents Source Code init Source Code subroutine init ( this ) class ( datetime ), intent ( inout ) :: this integer values ( 8 ) call date_and_time ( VALUES = values ) this % year = values ( 1 ) this % month = values ( 2 ) this % day = values ( 3 ) this % hour = values ( 5 ) this % minute = values ( 6 ) this % second = values ( 7 ) this % millisecond = values ( 8 ) end subroutine init","tags":"","loc":"proc/init.html"},{"title":"add_months – time_manager","text":"private pure subroutine add_months(this, months) Arguments Type Intent Optional Attributes Name class( datetime ), intent(inout) :: this integer, intent(in) :: months Contents Source Code add_months Source Code pure subroutine add_months ( this , months ) class ( datetime ), intent ( inout ) :: this integer , intent ( in ) :: months this % month = this % month + months if ( this % month > 12 ) then this % year = this % year + this % month / 12 this % month = mod ( this % month , 12 ) else if ( this % month < 1 ) then this % year = this % year + this % month / 12 - 1 this % month = 12 + mod ( this % month , 12 ) end if end subroutine add_months","tags":"","loc":"proc/add_months.html"},{"title":"add_days – time_manager","text":"private pure subroutine add_days(this, days) Arguments Type Intent Optional Attributes Name class( datetime ), intent(inout) :: this class(*), intent(in) :: days Calls proc~~add_days~~CallsGraph proc~add_days add_days proc~days_of_month days_of_month proc~add_days->proc~days_of_month proc~is_leap_year is_leap_year proc~days_of_month->proc~is_leap_year Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code add_days Source Code pure subroutine add_days ( this , days ) class ( datetime ), intent ( inout ) :: this class ( * ), intent ( in ) :: days real ( 8 ) residue_days integer month_days select type ( days ) type is ( integer ) residue_days = 0 this % day = this % day + days type is ( real ( 4 )) residue_days = days - int ( days ) this % day = this % day + days type is ( real ( 8 )) residue_days = days - int ( days ) this % day = this % day + days end select if ( residue_days /= 0 ) then call this % add_hours ( residue_days * 24 ) end if do if ( this % day < 1 ) then call this % add_months ( - 1 ) month_days = days_of_month ( this % year , this % month , this % calendar ) this % day = this % day + month_days else month_days = days_of_month ( this % year , this % month , this % calendar ) if ( this % day > month_days ) then call this % add_months ( 1 ) this % day = this % day - month_days else exit end if end if end do end subroutine add_days","tags":"","loc":"proc/add_days.html"},{"title":"add_hours – time_manager","text":"private pure subroutine add_hours(this, hours) Arguments Type Intent Optional Attributes Name class( datetime ), intent(inout) :: this class(*), intent(in) :: hours Contents Source Code add_hours Source Code pure subroutine add_hours ( this , hours ) class ( datetime ), intent ( inout ) :: this class ( * ), intent ( in ) :: hours real ( 8 ) residue_hours select type ( hours ) type is ( integer ) residue_hours = 0 this % hour = this % hour + hours type is ( real ( 4 )) residue_hours = hours - int ( hours ) this % hour = this % hour + hours type is ( real ( 8 )) residue_hours = hours - int ( hours ) this % hour = this % hour + hours end select if ( residue_hours /= 0 ) then call this % add_minutes ( residue_hours * 60 ) end if if ( this % hour >= 24 ) then call this % add_days ( this % hour / 24 ) this % hour = mod ( this % hour , 24 ) else if ( this % hour < 0 ) then if ( mod ( this % hour , 24 ) == 0 ) then call this % add_days ( this % hour / 24 ) this % hour = 0 else call this % add_days ( this % hour / 24 - 1 ) this % hour = mod ( this % hour , 24 ) + 24 end if end if end subroutine add_hours","tags":"","loc":"proc/add_hours.html"},{"title":"add_minutes – time_manager","text":"private pure subroutine add_minutes(this, minutes) Arguments Type Intent Optional Attributes Name class( datetime ), intent(inout) :: this class(*), intent(in) :: minutes Contents Source Code add_minutes Source Code pure subroutine add_minutes ( this , minutes ) class ( datetime ), intent ( inout ) :: this class ( * ), intent ( in ) :: minutes real ( 8 ) residue_minutes select type ( minutes ) type is ( integer ) residue_minutes = 0 this % minute = this % minute + minutes type is ( real ( 4 )) residue_minutes = minutes - int ( minutes ) this % minute = this % minute + minutes type is ( real ( 8 )) residue_minutes = minutes - int ( minutes ) this % minute = this % minute + minutes end select if ( residue_minutes /= 0 ) then call this % add_seconds ( residue_minutes * 60 ) end if if ( this % minute >= 60 ) then call this % add_hours ( this % minute / 60 ) this % minute = mod ( this % minute , 60 ) else if ( this % minute < 0 ) then if ( mod ( this % minute , 60 ) == 0 ) then call this % add_hours ( this % minute / 60 ) this % minute = 0 else call this % add_hours ( this % minute / 60 - 1 ) this % minute = mod ( this % minute , 60 ) + 60 end if end if end subroutine add_minutes","tags":"","loc":"proc/add_minutes.html"},{"title":"add_seconds – time_manager","text":"private pure subroutine add_seconds(this, seconds) Arguments Type Intent Optional Attributes Name class( datetime ), intent(inout) :: this class(*), intent(in) :: seconds Contents Source Code add_seconds Source Code pure subroutine add_seconds ( this , seconds ) class ( datetime ), intent ( inout ) :: this class ( * ), intent ( in ) :: seconds real ( 8 ) residue_seconds select type ( seconds ) type is ( integer ) residue_seconds = 0 this % second = this % second + seconds type is ( real ( 4 )) residue_seconds = seconds - int ( seconds ) this % second = this % second + seconds type is ( real ( 8 )) residue_seconds = seconds - int ( seconds ) this % second = this % second + seconds end select if ( residue_seconds /= 0 ) then call this % add_milliseconds ( residue_seconds * 1000 ) end if if ( this % second >= 60 ) then call this % add_minutes ( this % second / 60 ) this % second = mod ( this % second , 60 ) else if ( this % second < 0 ) then if ( mod ( this % second , 60 ) == 0 ) then call this % add_minutes ( this % second / 60 ) this % second = 0 else call this % add_minutes ( this % second / 60 - 1 ) this % second = mod ( this % second , 60 ) + 60 end if end if end subroutine add_seconds","tags":"","loc":"proc/add_seconds.html"},{"title":"add_milliseconds – time_manager","text":"private pure subroutine add_milliseconds(this, milliseconds) Arguments Type Intent Optional Attributes Name class( datetime ), intent(inout) :: this class(*), intent(in) :: milliseconds Contents Source Code add_milliseconds Source Code pure subroutine add_milliseconds ( this , milliseconds ) class ( datetime ), intent ( inout ) :: this class ( * ), intent ( in ) :: milliseconds select type ( milliseconds ) type is ( integer ) this % millisecond = this % millisecond + milliseconds type is ( real ( 4 )) this % millisecond = this % millisecond + milliseconds type is ( real ( 8 )) this % millisecond = this % millisecond + milliseconds end select if ( this % millisecond >= 1000 ) then call this % add_seconds ( int ( this % millisecond / 1000 )) this % millisecond = mod ( this % millisecond , 100 0.0 ) else if ( this % millisecond < 0 ) then if ( mod ( this % millisecond , 100 0.0 ) == 0 ) then call this % add_seconds ( int ( this % millisecond / 1000 )) this % millisecond = 0 else call this % add_seconds ( int ( this % millisecond / 1000 ) - 1 ) this % millisecond = mod ( this % millisecond , 100 0.0d0 ) + 1000 end if end if end subroutine add_milliseconds","tags":"","loc":"proc/add_milliseconds.html"},{"title":"assign – time_manager","text":"private pure elemental subroutine assign(this, other) Arguments Type Intent Optional Attributes Name class( datetime ), intent(inout) :: this class( datetime ), intent(in) :: other Contents Source Code assign Source Code pure elemental subroutine assign ( this , other ) class ( datetime ), intent ( inout ) :: this class ( datetime ), intent ( in ) :: other this % calendar = other % calendar this % year = other % year this % month = other % month this % day = other % day this % hour = other % hour this % minute = other % minute this % second = other % second this % millisecond = other % millisecond this % timezone = other % timezone end subroutine assign","tags":"","loc":"proc/assign.html"},{"title":"timedelta – time_manager","text":"public interface timedelta initial function set to the same name with type Calls interface~~timedelta~~CallsGraph interface~timedelta timedelta proc~create_timedelta create_timedelta interface~timedelta->proc~create_timedelta Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~timedelta~~CalledByGraph interface~timedelta timedelta proc~create_clock create_clock proc~create_clock->interface~timedelta proc~timedelta_plus_timedelta timedelta_plus_timedelta proc~timedelta_plus_timedelta->interface~timedelta interface~clock clock interface~clock->proc~create_clock Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures create_timedelta Module Procedures private pure function create_timedelta (days, hours, minutes, seconds, milliseconds) result(res) Arguments Type Intent Optional Attributes Name class(*), intent(in), optional :: days class(*), intent(in), optional :: hours class(*), intent(in), optional :: minutes class(*), intent(in), optional :: seconds class(*), intent(in), optional :: milliseconds Return Value type( timedelta )","tags":"","loc":"interface/timedelta.html"},{"title":"datetime – time_manager","text":"public interface datetime initial function set to the same name with type Calls interface~~datetime~~CallsGraph interface~datetime datetime proc~create_datetime_1 create_datetime_1 interface~datetime->proc~create_datetime_1 proc~create_datetime_2 create_datetime_2 interface~datetime->proc~create_datetime_2 proc~accum_days accum_days proc~create_datetime_1->proc~accum_days proc~days_of_month days_of_month proc~create_datetime_1->proc~days_of_month proc~accum_days->proc~days_of_month proc~is_leap_year is_leap_year proc~days_of_month->proc~is_leap_year Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~datetime~~CalledByGraph interface~datetime datetime proc~ceiling_day ceiling_day proc~ceiling_day->interface~datetime proc~create_clock create_clock proc~create_clock->interface~datetime proc~ceiling_month ceiling_month proc~ceiling_month->interface~datetime proc~timestamp timestamp proc~timestamp->interface~datetime interface~clock clock interface~clock->proc~create_clock Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures create_datetime_1 create_datetime_2 Module Procedures private pure function create_datetime_1 (year, month, day, hour, minute, second, millisecond, julday, days, hours, minutes, seconds, timestamp, timezone, calendar) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: year integer, intent(in), optional :: month integer, intent(in), optional :: day integer, intent(in), optional :: hour integer, intent(in), optional :: minute integer, intent(in), optional :: second integer, intent(in), optional :: millisecond integer, intent(in), optional :: julday integer, intent(in), optional :: days integer, intent(in), optional :: hours integer, intent(in), optional :: minutes integer, intent(in), optional :: seconds class(*), intent(in), optional :: timestamp class(*), intent(in), optional :: timezone integer, intent(in), optional :: calendar Return Value type( datetime ) private function create_datetime_2 (datetime_str, format_str, timezone, calendar) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: datetime_str character(len=*), intent(in), optional :: format_str class(*), intent(in), optional :: timezone integer, intent(in), optional :: calendar Return Value type( datetime )","tags":"","loc":"interface/datetime.html"},{"title":"clock – time_manager","text":"public interface clock initial function set to the same name with type Calls interface~~clock~~CallsGraph interface~clock clock proc~create_clock create_clock interface~clock->proc~create_clock interface~datetime datetime proc~create_clock->interface~datetime interface~timedelta timedelta proc~create_clock->interface~timedelta proc~create_datetime_1 create_datetime_1 interface~datetime->proc~create_datetime_1 proc~create_datetime_2 create_datetime_2 interface~datetime->proc~create_datetime_2 proc~create_timedelta create_timedelta interface~timedelta->proc~create_timedelta proc~accum_days accum_days proc~create_datetime_1->proc~accum_days proc~days_of_month days_of_month proc~create_datetime_1->proc~days_of_month proc~accum_days->proc~days_of_month proc~is_leap_year is_leap_year proc~days_of_month->proc~is_leap_year var paninterfaceclockCallsGraph = svgPanZoom('#interfaceclockCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures create_clock Module Procedures private pure function create_clock (d0, d1, dt) result(res) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: d0 class( datetime ), intent(in) :: d1 class( timedelta ), intent(in) :: dt Return Value type( clock )","tags":"","loc":"interface/clock.html"},{"title":"time_manager – time_manager","text":"calendar type\n end definition type timedelta definition type datetime \n end definition type datetime definition type clock \n end definition type clock !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Used by module~~time_manager~~UsedByGraph module~time_manager time_manager program~test_time_manager~2 test_time_manager program~test_time_manager~2->module~time_manager program~test_time_manager test_time_manager program~test_time_manager->module~time_manager Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables gregorian noleap default_year default_units Interfaces timedelta datetime clock Derived Types timedelta datetime clock Functions create_clock create_timedelta total_seconds total_minutes total_hours total_days timedelta_plus_timedelta timedelta_minus_timedelta unary_minus_timedelta timedelta_div_timedelta timedelta_eq timedelta_neq timedelta_gt timedelta_ge timedelta_lt timedelta_le create_datetime_1 create_datetime_2 isoformat timestamp format ceiling_day ceiling_month days_in_month days_in_year add_timedelta sub_timedelta sub_datetime eq neq gt ge lt le days_of_month accum_days days_of_year is_leap_year Subroutines reset tick init add_months add_days add_hours add_minutes add_seconds add_milliseconds assign Variables Type Visibility Attributes Name Initial integer, public, parameter :: gregorian = 1 base date integer, public, parameter :: noleap = 2 base date integer, private, parameter :: default_year = 0001 character(len=*), private, parameter :: default_units = 'days since 0001-01-01 00:00:00' definition type timedelta Interfaces public interface timedelta initial function set to the same name with type private pure function create_timedelta (days, hours, minutes, seconds, milliseconds) result(res) Arguments Type Intent Optional Attributes Name class(*), intent(in), optional :: days class(*), intent(in), optional :: hours class(*), intent(in), optional :: minutes class(*), intent(in), optional :: seconds class(*), intent(in), optional :: milliseconds Return Value type( timedelta ) public interface datetime initial function set to the same name with type private pure function create_datetime_1 (year, month, day, hour, minute, second, millisecond, julday, days, hours, minutes, seconds, timestamp, timezone, calendar) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: year integer, intent(in), optional :: month integer, intent(in), optional :: day integer, intent(in), optional :: hour integer, intent(in), optional :: minute integer, intent(in), optional :: second integer, intent(in), optional :: millisecond integer, intent(in), optional :: julday integer, intent(in), optional :: days integer, intent(in), optional :: hours integer, intent(in), optional :: minutes integer, intent(in), optional :: seconds class(*), intent(in), optional :: timestamp class(*), intent(in), optional :: timezone integer, intent(in), optional :: calendar Return Value type( datetime ) private function create_datetime_2 (datetime_str, format_str, timezone, calendar) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: datetime_str character(len=*), intent(in), optional :: format_str class(*), intent(in), optional :: timezone integer, intent(in), optional :: calendar Return Value type( datetime ) public interface clock initial function set to the same name with type private pure function create_clock (d0, d1, dt) result(res) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: d0 class( datetime ), intent(in) :: d1 class( timedelta ), intent(in) :: dt Return Value type( clock ) Derived Types type, public :: timedelta Components Type Visibility Attributes Name Initial real(kind=8), public :: days = 0.0d0 real(kind=8), public :: hours = 0.0d0 real(kind=8), public :: minutes = 0.0d0 real(kind=8), public :: seconds = 0.0d0 real(kind=8), public :: milliseconds = 0.0d0 Constructor initial function set to the same name with type private pure function create_timedelta (days, hours, minutes, seconds, milliseconds) Type-Bound Procedures procedure, public :: total_seconds procedure, public :: total_minutes procedure, public :: total_hours procedure, public :: total_days procedure, private :: timedelta_plus_timedelta procedure, private :: timedelta_minus_timedelta procedure, private :: unary_minus_timedelta procedure, private :: timedelta_div_timedelta procedure, private :: timedelta_eq procedure, private :: timedelta_neq procedure, private :: timedelta_gt procedure, private :: timedelta_ge procedure, private :: timedelta_lt procedure, private :: timedelta_le generic, public :: operator(+) => timedelta_plus_timedelta generic, public :: operator(-) => timedelta_minus_timedelta, unary_minus_timedelta generic, public :: operator(/) => timedelta_div_timedelta generic, public :: operator(==) => timedelta_eq generic, public :: operator(/=) => timedelta_neq generic, public :: operator(>) => timedelta_gt generic, public :: operator(>=) => timedelta_ge generic, public :: operator( => timedelta_lt generic, public :: operator(<=) => timedelta_le type, public :: datetime Components Type Visibility Attributes Name Initial integer, public :: calendar = gregorian integer, public :: year = 1 integer, public :: month = 1 integer, public :: day = 1 integer, public :: hour = 0 integer, public :: minute = 0 integer, public :: second = 0 real(kind=8), public :: millisecond = 0 real(kind=8), public :: timezone = 0.0d0 Constructor initial function set to the same name with type private pure function create_datetime_1 (year, month, day, hour, minute, second, millisecond, julday, days, hours, minutes, seconds, timestamp, timezone, calendar) private  function create_datetime_2 (datetime_str, format_str, timezone, calendar) Type-Bound Procedures procedure, public :: init procedure, public :: isoformat procedure, public :: timestamp procedure, public :: format procedure, public :: add_months procedure, public :: add_days procedure, public :: add_hours procedure, public :: add_minutes procedure, public :: add_seconds procedure, public :: add_milliseconds procedure, public :: days_in_month procedure, public :: days_in_year procedure, public :: ceiling_month procedure, public :: ceiling_day procedure, private :: assign procedure, private :: add_timedelta procedure, private :: sub_datetime procedure, private :: sub_timedelta procedure, private :: eq procedure, private :: neq procedure, private :: gt procedure, private :: ge procedure, private :: lt procedure, private :: le generic, public :: assignment(=) => assign generic, public :: operator(+) => add_timedelta generic, public :: operator(-) => sub_datetime, sub_timedelta generic, public :: operator(==) => eq generic, public :: operator(/=) => neq generic, public :: operator(>) => gt generic, public :: operator(>=) => ge generic, public :: operator( => lt generic, public :: operator(<=) => le type, public :: clock Components Type Visibility Attributes Name Initial type( datetime ), public :: strtTime type( datetime ), public :: lastTime type( datetime ), public :: Time type( datetime ), public :: prevTime type( timedelta ), public :: dt logical, public :: started = .false. logical, public :: stopped = .false. logical, public :: alarm_d repeat alarm for daily integer, public :: index_d = 0 real(kind=8), public :: axis_d = 0.d0 logical, public :: alarm_m repeat alarm for monthly integer, public :: index_m = 0 real(kind=8), public :: axis_m = 0.d0 Constructor initial function set to the same name with type private pure function create_clock (d0, d1, dt) Type-Bound Procedures procedure, public :: reset procedure, public :: tick Functions private pure function create_clock (d0, d1, dt) result(res) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: d0 class( datetime ), intent(in) :: d1 class( timedelta ), intent(in) :: dt Return Value type( clock ) private pure function create_timedelta (days, hours, minutes, seconds, milliseconds) result(res) Arguments Type Intent Optional Attributes Name class(*), intent(in), optional :: days class(*), intent(in), optional :: hours class(*), intent(in), optional :: minutes class(*), intent(in), optional :: seconds class(*), intent(in), optional :: milliseconds Return Value type( timedelta ) private pure function total_seconds (this) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: this Return Value real(kind=8) private pure function total_minutes (this) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: this Return Value real(kind=8) private pure function total_hours (this) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: this Return Value real(kind=8) private pure function total_days (this) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: this Return Value real(kind=8) private pure elemental function timedelta_plus_timedelta (t0, t1) result(t) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: t0 class( timedelta ), intent(in) :: t1 Return Value type( timedelta ) private pure elemental function timedelta_minus_timedelta (t0, t1) result(t) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: t0 class( timedelta ), intent(in) :: t1 Return Value type( timedelta ) private pure elemental function unary_minus_timedelta (t0) result(t) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: t0 Return Value type( timedelta ) private pure elemental function timedelta_div_timedelta (t0, t1) result(factor) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: t0 class( timedelta ), intent(in) :: t1 Return Value real(kind=8) private pure elemental function timedelta_eq (this, other) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: this class( timedelta ), intent(in) :: other Return Value logical private pure elemental function timedelta_neq (this, other) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: this class( timedelta ), intent(in) :: other Return Value logical private pure elemental function timedelta_gt (this, other) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: this class( timedelta ), intent(in) :: other Return Value logical private pure elemental function timedelta_ge (this, other) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: this class( timedelta ), intent(in) :: other Return Value logical private pure elemental function timedelta_lt (this, other) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: this class( timedelta ), intent(in) :: other Return Value logical private pure elemental function timedelta_le (this, other) Arguments Type Intent Optional Attributes Name class( timedelta ), intent(in) :: this class( timedelta ), intent(in) :: other Return Value logical private pure function create_datetime_1 (year, month, day, hour, minute, second, millisecond, julday, days, hours, minutes, seconds, timestamp, timezone, calendar) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: year integer, intent(in), optional :: month integer, intent(in), optional :: day integer, intent(in), optional :: hour integer, intent(in), optional :: minute integer, intent(in), optional :: second integer, intent(in), optional :: millisecond integer, intent(in), optional :: julday integer, intent(in), optional :: days integer, intent(in), optional :: hours integer, intent(in), optional :: minutes integer, intent(in), optional :: seconds class(*), intent(in), optional :: timestamp class(*), intent(in), optional :: timezone integer, intent(in), optional :: calendar Return Value type( datetime ) private function create_datetime_2 (datetime_str, format_str, timezone, calendar) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: datetime_str character(len=*), intent(in), optional :: format_str class(*), intent(in), optional :: timezone integer, intent(in), optional :: calendar Return Value type( datetime ) private function isoformat (this) result(res) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this Return Value character(len=:),\n  allocatable private function timestamp (this, timezone) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this class(*), intent(in), optional :: timezone Return Value real(kind=8) private function format (this, format_str) result(res) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this character(len=*), intent(in) :: format_str Return Value character(len=:),\n  allocatable private pure function ceiling_day (this) result(res) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this Return Value type( datetime ) private pure function ceiling_month (this) result(res) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this Return Value type( datetime ) private pure function days_in_month (this) result(res) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this Return Value real(kind=8) private pure function days_in_year (this) result(res) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this Return Value real(kind=8) private elemental function add_timedelta (this, td) result(res) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this type( timedelta ), intent(in) :: td Return Value type( datetime ) private pure elemental function sub_timedelta (this, td) result(res) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this type( timedelta ), intent(in) :: td Return Value type( datetime ) private recursive function sub_datetime (this, other) result(res) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this class( datetime ), intent(in) :: other Return Value type( timedelta ) private pure elemental function eq (this, other) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this class( datetime ), intent(in) :: other Return Value logical private pure elemental function neq (this, other) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this class( datetime ), intent(in) :: other Return Value logical private pure elemental function gt (this, other) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this class( datetime ), intent(in) :: other Return Value logical private pure elemental function ge (this, other) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this class( datetime ), intent(in) :: other Return Value logical private pure elemental function lt (this, other) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this class( datetime ), intent(in) :: other Return Value logical private pure elemental function le (this, other) Arguments Type Intent Optional Attributes Name class( datetime ), intent(in) :: this class( datetime ), intent(in) :: other Return Value logical public pure function days_of_month (year, month, calendar) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: year integer, intent(in) :: month integer, intent(in) :: calendar Return Value integer public pure function accum_days (year, month, day, calendar) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: year integer, intent(in) :: month integer, intent(in) :: day integer, intent(in) :: calendar Return Value integer public pure function days_of_year (year, calendar) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: year integer, intent(in) :: calendar Return Value integer public pure function is_leap_year (year) result(res) Arguments Type Intent Optional Attributes Name integer, intent(in) :: year Return Value logical Subroutines private pure elemental subroutine reset (this) Arguments Type Intent Optional Attributes Name class( clock ), intent(inout) :: this private pure elemental subroutine tick (this) alarm for daily\n alarm for monthly Arguments Type Intent Optional Attributes Name class( clock ), intent(inout) :: this private subroutine init (this) Arguments Type Intent Optional Attributes Name class( datetime ), intent(inout) :: this private pure subroutine add_months (this, months) Arguments Type Intent Optional Attributes Name class( datetime ), intent(inout) :: this integer, intent(in) :: months private pure subroutine add_days (this, days) Arguments Type Intent Optional Attributes Name class( datetime ), intent(inout) :: this class(*), intent(in) :: days private pure subroutine add_hours (this, hours) Arguments Type Intent Optional Attributes Name class( datetime ), intent(inout) :: this class(*), intent(in) :: hours private pure subroutine add_minutes (this, minutes) Arguments Type Intent Optional Attributes Name class( datetime ), intent(inout) :: this class(*), intent(in) :: minutes private pure subroutine add_seconds (this, seconds) Arguments Type Intent Optional Attributes Name class( datetime ), intent(inout) :: this class(*), intent(in) :: seconds private pure subroutine add_milliseconds (this, milliseconds) Arguments Type Intent Optional Attributes Name class( datetime ), intent(inout) :: this class(*), intent(in) :: milliseconds private pure elemental subroutine assign (this, other) Arguments Type Intent Optional Attributes Name class( datetime ), intent(inout) :: this class( datetime ), intent(in) :: other","tags":"","loc":"module/time_manager.html"},{"title":"test_time_manager – time_manager","text":"Uses time_manager program~~test_time_manager~~UsesGraph program~test_time_manager test_time_manager module~time_manager time_manager program~test_time_manager->module~time_manager Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. write( , ) clock_atmos%Time%days_in_year() Contents Variables dt_atmos dt_ocean dt_cpl dt_tmp Time_curr Time_strt Time_last clock_atmos clock_ocean factor days_prev Source Code test_time_manager Variables Type Attributes Name Initial type( timedelta ) :: dt_atmos type( timedelta ) :: dt_ocean type( timedelta ) :: dt_cpl type( timedelta ) :: dt_tmp type( datetime ) :: Time_curr type( datetime ) :: Time_strt type( datetime ) :: Time_last type( clock ) :: clock_atmos type( clock ) :: clock_ocean real(kind=8) :: factor real(kind=8) :: days_prev Source Code program test_time_manager use time_manager implicit none type ( timedelta ) dt_atmos , dt_ocean , dt_cpl , dt_tmp type ( datetime ) Time_curr , Time_strt , Time_last type ( clock ) clock_atmos , clock_ocean real ( 8 ) :: factor , days_prev !! dt_atmos = timedelta ( hours = 4 ) dt_ocean = timedelta ( hours = 12 ) write ( * , * ) dt_atmos % total_days (), \" to \" , dt_ocean % total_days () dt_cpl = dt_ocean - dt_atmos write ( * , * ) dt_cpl % total_hours () dt_cpl = - dt_atmos write ( * , * ) dt_cpl % total_hours () factor = dt_ocean / dt_atmos write ( * , * ) factor Time_strt = datetime ( 1980 , 1 , 1 , 0 , 0 , 0 , calendar = gregorian ) Time_last = datetime ( 1981 , 1 , 1 , 0 , 0 , 0 , calendar = gregorian ) write ( * , * ) Time_strt % isoformat (), \" to \" , Time_last % isoformat () clock_atmos = clock ( Time_strt , Time_last , dt_atmos ) do while (. not . clock_atmos % stopped ) !! write(*, *) clock_atmos%Time%days_in_year() days_prev = int ( clock_atmos % Time % days_in_month ()) call clock_atmos % tick () if ( clock_atmos % alarm_d ) then write ( * , '(A, F12.1, I12, F12.1)' ) clock_atmos % Time % isoformat (), clock_atmos % Time % days_in_year (), clock_atmos % index_d , clock_atmos % axis_d end if !      if( clock_atmos%alarm_m ) then !          write(*, *) clock_atmos%Time%isoformat(), clock_atmos%index_m, clock_atmos%axis_m !      end if end do end program test_time_manager","tags":"","loc":"program/test_time_manager.html"},{"title":"test_time_manager – time_manager","text":"Uses time_manager program~~test_time_manager~2~~UsesGraph program~test_time_manager~2 test_time_manager module~time_manager time_manager program~test_time_manager~2->module~time_manager Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables dt_atmos Time_strt Time_last jm namelist_file_exists Source Code test_time_manager Variables Type Attributes Name Initial type( timedelta ) :: dt_atmos type( datetime ) :: Time_strt type( datetime ) :: Time_last integer :: jm logical :: namelist_file_exists Source Code program test_time_manager use time_manager implicit none type ( timedelta ) dt_atmos type ( datetime ) Time_strt , Time_last namelist / time_nml / Time_strt , Time_last , dt_atmos integer :: jm logical :: namelist_file_exists ! Read namelist file inquire ( file = \"input.nml\" , exist = namelist_file_exists ) if ( namelist_file_exists ) then open ( 10 , file = \"input.nml\" ) read ( 10 , nml = time_nml ) close ( 10 ) end if write ( * , '(2A)' ) \" Model runs from \" , Time_strt % isoformat () write ( * , '(2A)' ) \" Model ends at   \" , Time_last % isoformat () write ( * , '(A, F5.3, A)' ) \" dt_atmos = \" , dt_atmos % total_hours (), \" hours\" end program test_time_manager","tags":"","loc":"program/test_time_manager~2.html"}]}